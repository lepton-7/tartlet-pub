Settings:
  Output files: "Cobalamin_index/Cobalamin_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  Cobalamin.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 441 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 441 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 6; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 335.286 (target: 440)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 7
Getting block 2 of 7
  Reserving size (441) for bucket 2
  Reserving size (441) for bucket 1
  Calculating Z arrays for bucket 2
Getting block 4 of 7
Getting block 3 of 7
  Reserving size (441) for bucket 3
Getting block 5 of 7
  Reserving size (441) for bucket 5
Getting block 6 of 7
  Entering block accumulator loop for bucket 2:
  Calculating Z arrays for bucket 3
  Calculating Z arrays for bucket 5
  Calculating Z arrays for bucket 1
  Reserving size (441) for bucket 6
  Reserving size (441) for bucket 4
  bucket 2: 10%
  Calculating Z arrays for bucket 6
Getting block 7 of 7
  Entering block accumulator loop for bucket 3:
  Calculating Z arrays for bucket 4
  Entering block accumulator loop for bucket 6:
  Reserving size (441) for bucket 7
  Entering block accumulator loop for bucket 1:
  Entering block accumulator loop for bucket 5:
  bucket 2: 20%
  bucket 1: 10%
  bucket 3: 10%
  Calculating Z arrays for bucket 7
  Entering block accumulator loop for bucket 4:
  bucket 1: 20%
  bucket 2: 30%
  bucket 3: 20%
  bucket 1: 30%
  bucket 2: 40%
  Entering block accumulator loop for bucket 7:
  bucket 3: 30%
  bucket 4: 10%
  bucket 2: 50%
  bucket 7: 10%
  bucket 3: 40%
  bucket 1: 40%
  bucket 5: 10%
  bucket 3: 50%
  bucket 6: 10%
  bucket 4: 20%
  bucket 7: 20%
  bucket 1: 50%
  bucket 2: 60%
  bucket 7: 30%
  bucket 4: 30%
  bucket 1: 60%
  bucket 6: 20%
  bucket 5: 20%
  bucket 1: 70%
  bucket 7: 40%
  bucket 2: 70%
  bucket 5: 30%
  bucket 7: 50%
  bucket 4: 40%
  bucket 2: 80%
  bucket 3: 60%
  bucket 6: 30%
  bucket 1: 80%
  bucket 2: 90%
  bucket 3: 70%
  bucket 4: 50%
  bucket 7: 60%
  bucket 6: 40%
  bucket 4: 60%
  bucket 3: 80%
  bucket 2: 100%
  bucket 4: 70%
  bucket 1: 90%
  bucket 3: 90%
  bucket 5: 40%
  Sorting block of length 389 for bucket 2
  bucket 4: 80%
  (Using difference cover)
  bucket 6: 50%
  bucket 7: 70%
  bucket 3: 100%
  bucket 6: 60%
  bucket 4: 90%
  bucket 7: 80%
  bucket 5: 50%
  bucket 6: 70%
  bucket 1: 100%
  bucket 4: 100%
  bucket 6: 80%
  bucket 5: 60%
  Sorting block of length 396 for bucket 3
  (Using difference cover)
  Sorting block of length 241 for bucket 4
  (Using difference cover)
  bucket 7: 90%
  Sorting block of length 347 for bucket 1
  (Using difference cover)
  bucket 7: 100%
  bucket 6: 90%
  bucket 5: 70%
  Sorting block of length 375 for bucket 7
  (Using difference cover)
  bucket 6: 100%
  Sorting block of length 217 for bucket 6
  (Using difference cover)
  bucket 5: 80%
  bucket 5: 90%
  bucket 5: 100%
  Sorting block of length 382 for bucket 5
  (Using difference cover)
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 397 for bucket 3
Returning block of 348 for bucket 1
Returning block of 390 for bucket 2
Returning block of 242 for bucket 4
  Sorting block time: 00:00:00
Returning block of 218 for bucket 6
  Sorting block time: 00:00:00
Returning block of 383 for bucket 5
  Sorting block time: 00:00:00
Returning block of 376 for bucket 7
Exited GFM loop
fchr[A]: 0
fchr[C]: 709
fchr[G]: 1123
fchr[T]: 1617
fchr[$]: 2353
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4195411 bytes to primary GFM file: Cobalamin_index/Cobalamin_index.1.ht2
Wrote 596 bytes to secondary GFM file: Cobalamin_index/Cobalamin_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 17325 bytes to primary GFM file: Cobalamin_index/Cobalamin_index.5.ht2
Wrote 596 bytes to secondary GFM file: Cobalamin_index/Cobalamin_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 2353
    gbwtLen: 2354
    nodes: 2354
    sz: 589
    gbwtSz: 589
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 148
    offsSz: 592
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 13
    numLines: 13
    gbwtTotLen: 832
    gbwtTotSz: 832
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "Fluoride_index/Fluoride_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  Fluoride.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 399 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 399 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 6; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 303.571 (target: 398)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 7
  Reserving size (399) for bucket 1
Getting block 2 of 7
  Reserving size (399) for bucket 2
Getting block 3 of 7
  Reserving size (399) for bucket 3
  Calculating Z arrays for bucket 1
  Calculating Z arrays for bucket 2
Getting block 4 of 7
  Reserving size (399) for bucket 4
  Entering block accumulator loop for bucket 2:
  Calculating Z arrays for bucket 3
Getting block 6 of 7
Getting block 7 of 7
  Reserving size (399) for bucket 7
  Entering block accumulator loop for bucket 1:
  Calculating Z arrays for bucket 4
  Calculating Z arrays for bucket 7
Getting block 5 of 7
  Reserving size (399) for bucket 5
  Entering block accumulator loop for bucket 4:
  Calculating Z arrays for bucket 5
  Reserving size (399) for bucket 6
  Entering block accumulator loop for bucket 3:
  bucket 1: 10%
  Calculating Z arrays for bucket 6
  Entering block accumulator loop for bucket 7:
  bucket 4: 10%
  Entering block accumulator loop for bucket 5:
  bucket 7: 10%
  bucket 2: 10%
  bucket 3: 10%
  bucket 1: 20%
  bucket 2: 20%
  bucket 3: 20%
  bucket 4: 20%
  bucket 2: 30%
  bucket 3: 30%
  bucket 2: 40%
  Entering block accumulator loop for bucket 6:
  bucket 5: 10%
  bucket 2: 50%
  bucket 3: 40%
  bucket 5: 20%
  bucket 6: 10%
  bucket 2: 60%
  bucket 3: 50%
  bucket 6: 20%
  bucket 2: 70%
  bucket 1: 30%
  bucket 2: 80%
  bucket 6: 30%
  bucket 7: 20%
  bucket 2: 90%
  bucket 6: 40%
  bucket 3: 60%
  bucket 2: 100%
  bucket 5: 30%
  bucket 4: 30%
  Sorting block of length 295 for bucket 2
  (Using difference cover)
  bucket 6: 50%
  bucket 5: 40%
  bucket 4: 40%
  bucket 6: 60%
  bucket 1: 40%
  bucket 6: 70%
  bucket 5: 50%
  bucket 3: 70%
  bucket 1: 50%
  bucket 5: 60%
  bucket 3: 80%
  bucket 6: 80%
  bucket 7: 30%
  bucket 4: 50%
  bucket 5: 70%
  bucket 6: 90%
  bucket 3: 90%
  bucket 5: 80%
  bucket 7: 40%
  bucket 3: 100%
  bucket 6: 100%
  Sorting block of length 359 for bucket 3
  bucket 1: 60%
  bucket 7: 50%
  (Using difference cover)
  bucket 5: 90%
  bucket 1: 70%
  bucket 4: 60%
  Sorting block of length 59 for bucket 6
  (Using difference cover)
  bucket 7: 60%
  bucket 5: 100%
  bucket 4: 70%
  Sorting block of length 376 for bucket 5
  (Using difference cover)
  bucket 7: 70%
  bucket 4: 80%
  bucket 1: 80%
  bucket 7: 80%
  bucket 4: 90%
  bucket 7: 90%
  bucket 1: 90%
  bucket 4: 100%
  bucket 7: 100%
  Sorting block of length 333 for bucket 4
  (Using difference cover)
  Sorting block of length 375 for bucket 7
  (Using difference cover)
  bucket 1: 100%
  Sorting block of length 328 for bucket 1
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 296 for bucket 2
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 377 for bucket 5
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 334 for bucket 4
Returning block of 329 for bucket 1
Returning block of 360 for bucket 3
Returning block of 376 for bucket 7
  Sorting block time: 00:00:00
Returning block of 60 for bucket 6
Exited GFM loop
fchr[A]: 0
fchr[C]: 664
fchr[G]: 1012
fchr[T]: 1468
fchr[$]: 2131
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4195341 bytes to primary GFM file: Fluoride_index/Fluoride_index.1.ht2
Wrote 540 bytes to secondary GFM file: Fluoride_index/Fluoride_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 17197 bytes to primary GFM file: Fluoride_index/Fluoride_index.5.ht2
Wrote 540 bytes to secondary GFM file: Fluoride_index/Fluoride_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 2131
    gbwtLen: 2132
    nodes: 2132
    sz: 533
    gbwtSz: 534
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 134
    offsSz: 536
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 12
    numLines: 12
    gbwtTotLen: 768
    gbwtTotSz: 768
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "Glycine_index/Glycine_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  Glycine.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 207 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 207 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 2, merged 7; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 1; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 157 (target: 206)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 7
Getting block 2 of 7
  Reserving size (207) for bucket 2
Getting block 3 of 7
  Reserving size (207) for bucket 3
  Reserving size (207) for bucket 1
  Calculating Z arrays for bucket 2
Getting block 6 of 7
  Reserving size (207) for bucket 6
  Calculating Z arrays for bucket 3
Getting block 7 of 7
  Reserving size (207) for bucket 7
  Entering block accumulator loop for bucket 3:
  Entering block accumulator loop for bucket 2:
  Calculating Z arrays for bucket 7
  bucket 2: 10%
Getting block 4 of 7
  Calculating Z arrays for bucket 6
  Entering block accumulator loop for bucket 7:
  bucket 2: 20%
  Reserving size (207) for bucket 4
Getting block 5 of 7
  Reserving size (207) for bucket 5
  Entering block accumulator loop for bucket 6:
  Calculating Z arrays for bucket 4
  Calculating Z arrays for bucket 5
  bucket 2: 30%
  Calculating Z arrays for bucket 1
  bucket 2: 40%
  bucket 6: 10%
  bucket 2: 50%
  bucket 6: 20%
  bucket 7: 10%
  bucket 2: 60%
  bucket 3: 10%
  bucket 2: 70%
  bucket 6: 30%
  Entering block accumulator loop for bucket 1:
  Entering block accumulator loop for bucket 5:
  bucket 3: 20%
  bucket 2: 80%
  Entering block accumulator loop for bucket 4:
  bucket 5: 10%
  bucket 6: 40%
  bucket 5: 20%
  bucket 2: 90%
  bucket 4: 10%
  bucket 2: 100%
  bucket 5: 30%
  Sorting block of length 182 for bucket 2
  (Using difference cover)
  bucket 3: 30%
  bucket 7: 20%
  bucket 5: 40%
  bucket 1: 10%
  bucket 5: 50%
  bucket 1: 20%
  bucket 5: 60%
  bucket 7: 30%
  bucket 6: 50%
  bucket 5: 70%
  bucket 3: 40%
  bucket 4: 20%
  bucket 5: 80%
  bucket 6: 60%
  bucket 1: 30%
  bucket 5: 90%
  bucket 6: 70%
  bucket 7: 40%
  bucket 5: 100%
  bucket 6: 80%
  bucket 1: 40%
  bucket 4: 30%
  Sorting block of length 197 for bucket 5
  bucket 7: 50%
  (Using difference cover)
  bucket 6: 90%
  bucket 4: 40%
  bucket 3: 50%
  bucket 7: 60%
  bucket 6: 100%
  bucket 3: 60%
  bucket 4: 50%
  Sorting block of length 132 for bucket 6
  (Using difference cover)
  bucket 4: 60%
  bucket 3: 70%
  bucket 7: 70%
  bucket 4: 70%
  bucket 3: 80%
  bucket 4: 80%
  bucket 1: 50%
  bucket 7: 80%
  bucket 4: 90%
  bucket 3: 90%
  bucket 1: 60%
  bucket 7: 90%
  bucket 3: 100%
  bucket 7: 100%
  Sorting block of length 182 for bucket 3
  (Using difference cover)
  bucket 4: 100%
  bucket 1: 70%
  Sorting block of length 28 for bucket 4
  (Using difference cover)
  bucket 1: 80%
  Sorting block of length 205 for bucket 7
  (Using difference cover)
  bucket 1: 90%
  bucket 1: 100%
  Sorting block of length 173 for bucket 1
  (Using difference cover)
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 29 for bucket 4
  Sorting block time: 00:00:00
Returning block of 183 for bucket 3
Returning block of 183 for bucket 2
  Sorting block time: 00:00:00
Returning block of 206 for bucket 7
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 133 for bucket 6
  Sorting block time: 00:00:00
Returning block of 174 for bucket 1
Returning block of 198 for bucket 5
Exited GFM loop
fchr[A]: 0
fchr[C]: 332
fchr[G]: 546
fchr[T]: 766
fchr[$]: 1105
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4194906 bytes to primary GFM file: Glycine_index/Glycine_index.1.ht2
Wrote 284 bytes to secondary GFM file: Glycine_index/Glycine_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 8613 bytes to primary GFM file: Glycine_index/Glycine_index.5.ht2
Wrote 282 bytes to secondary GFM file: Glycine_index/Glycine_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 1105
    gbwtLen: 1106
    nodes: 1106
    sz: 277
    gbwtSz: 277
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 70
    offsSz: 280
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 6
    numLines: 6
    gbwtTotLen: 384
    gbwtTotSz: 384
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "Lysine_index/Lysine_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  Lysine.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 442 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 442 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 7; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 335.857 (target: 441)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 7
  Reserving size (442) for bucket 1
  Calculating Z arrays for bucket 1
Getting block 2 of 7
  Reserving size (442) for bucket 2
  Entering block accumulator loop for bucket 1:
Getting block 3 of 7
  Reserving size (442) for bucket 3
  bucket 1: 10%
Getting block 4 of 7
  Reserving size (442) for bucket 4
Getting block 5 of 7
  Reserving size (442) for bucket 5
Getting block 6 of 7
  Reserving size (442) for bucket 6
Getting block 7 of 7
  Calculating Z arrays for bucket 5
  Calculating Z arrays for bucket 3
  Calculating Z arrays for bucket 2
  Calculating Z arrays for bucket 6
  bucket 1: 20%
  Calculating Z arrays for bucket 4
  bucket 1: 30%
  Reserving size (442) for bucket 7
  bucket 1: 40%
  Entering block accumulator loop for bucket 2:
  bucket 1: 50%
  bucket 2: 10%
  bucket 1: 60%
  bucket 2: 20%
  bucket 1: 70%
  bucket 2: 30%
  bucket 1: 80%
  bucket 2: 40%
  bucket 1: 90%
  bucket 2: 50%
  bucket 1: 100%
  Sorting block of length 376 for bucket 1
  (Using difference cover)
  bucket 2: 60%
  bucket 2: 70%
  bucket 2: 80%
  bucket 2: 90%
  bucket 2: 100%
  Sorting block of length 172 for bucket 2
  (Using difference cover)
  Calculating Z arrays for bucket 7
  Entering block accumulator loop for bucket 5:
  Entering block accumulator loop for bucket 3:
  bucket 5: 10%
  bucket 3: 10%
  bucket 5: 20%
  bucket 3: 20%
  bucket 5: 30%
  bucket 3: 30%
  bucket 5: 40%
  bucket 3: 40%
  Entering block accumulator loop for bucket 7:
  bucket 5: 50%
  bucket 3: 50%
  Entering block accumulator loop for bucket 4:
  bucket 5: 60%
  bucket 3: 60%
  Entering block accumulator loop for bucket 6:
  bucket 3: 70%
  bucket 7: 10%
  bucket 4: 10%
  bucket 7: 20%
  bucket 5: 70%
  bucket 6: 10%
  bucket 7: 30%
  bucket 3: 80%
  bucket 4: 20%
  bucket 6: 20%
  bucket 3: 90%
  bucket 7: 40%
  bucket 6: 30%
  bucket 5: 80%
  bucket 4: 30%
  bucket 6: 40%
  bucket 3: 100%
  bucket 7: 50%
  Sorting block of length 428 for bucket 3
  (Using difference cover)
  bucket 4: 40%
  bucket 6: 50%
  bucket 7: 60%
  bucket 5: 90%
  bucket 7: 70%
  bucket 6: 60%
  bucket 5: 100%
  bucket 7: 80%
  Sorting block of length 259 for bucket 5
  (Using difference cover)
  bucket 4: 50%
  bucket 7: 90%
  bucket 6: 70%
  bucket 4: 60%
  bucket 7: 100%
  Sorting block of length 344 for bucket 7
  (Using difference cover)
  bucket 4: 70%
  bucket 6: 80%
  bucket 4: 80%
  bucket 6: 90%
  bucket 4: 90%
  bucket 6: 100%
  Sorting block of length 385 for bucket 6
  (Using difference cover)
  bucket 4: 100%
  Sorting block of length 387 for bucket 4
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 377 for bucket 1
  Sorting block time: 00:00:00
Returning block of 173 for bucket 2
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 386 for bucket 6
  Sorting block time: 00:00:00
Returning block of 345 for bucket 7
Returning block of 388 for bucket 4
  Sorting block time: 00:00:00
Returning block of 429 for bucket 3
Returning block of 260 for bucket 5
Exited GFM loop
fchr[A]: 0
fchr[C]: 742
fchr[G]: 1152
fchr[T]: 1586
fchr[$]: 2357
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4195403 bytes to primary GFM file: Lysine_index/Lysine_index.1.ht2
Wrote 596 bytes to secondary GFM file: Lysine_index/Lysine_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 17325 bytes to primary GFM file: Lysine_index/Lysine_index.5.ht2
Wrote 594 bytes to secondary GFM file: Lysine_index/Lysine_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 2357
    gbwtLen: 2358
    nodes: 2358
    sz: 590
    gbwtSz: 590
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 148
    offsSz: 592
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 13
    numLines: 13
    gbwtTotLen: 832
    gbwtTotSz: 832
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "MOCO_RNA_motif_index/MOCO_RNA_motif_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  MOCO_RNA_motif.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 216 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 216 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 2, merged 7; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 163.143 (target: 215)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 7
  Reserving size (216) for bucket 1
Getting block 2 of 7
  Reserving size (216) for bucket 2
  Calculating Z arrays for bucket 1
Getting block 3 of 7
  Reserving size (216) for bucket 3
  Entering block accumulator loop for bucket 1:
  Calculating Z arrays for bucket 3
Getting block 6 of 7
  Reserving size (216) for bucket 6
  Entering block accumulator loop for bucket 3:
  bucket 1: 10%
Getting block 5 of 7
  bucket 1: 20%
Getting block 4 of 7
  Reserving size (216) for bucket 4
  bucket 1: 30%
  Calculating Z arrays for bucket 4
Getting block 7 of 7
  Reserving size (216) for bucket 7
  Entering block accumulator loop for bucket 4:
  Calculating Z arrays for bucket 2
  Reserving size (216) for bucket 5
  Calculating Z arrays for bucket 7
  bucket 1: 40%
  Calculating Z arrays for bucket 5
  bucket 4: 10%
  bucket 1: 50%
  Entering block accumulator loop for bucket 7:
  bucket 4: 20%
  Entering block accumulator loop for bucket 2:
  bucket 1: 60%
  bucket 3: 10%
  bucket 1: 70%
  Entering block accumulator loop for bucket 5:
  bucket 3: 20%
  bucket 5: 10%
  bucket 2: 10%
  bucket 5: 20%
  bucket 3: 30%
  bucket 5: 30%
  bucket 1: 80%
  bucket 7: 10%
  bucket 3: 40%
  Calculating Z arrays for bucket 6
  bucket 1: 90%
  bucket 4: 30%
  bucket 7: 20%
  bucket 4: 40%
  bucket 5: 40%
  bucket 7: 30%
  bucket 4: 50%
  bucket 1: 100%
  bucket 7: 40%
  Entering block accumulator loop for bucket 6:
  bucket 3: 50%
  bucket 7: 50%
  Sorting block of length 173 for bucket 1
  bucket 5: 50%
  (Using difference cover)
  bucket 7: 60%
  bucket 3: 60%
  bucket 7: 70%
  bucket 2: 20%
  bucket 3: 70%
  bucket 4: 60%
  bucket 5: 60%
  bucket 7: 80%
  bucket 4: 70%
  bucket 6: 10%
  bucket 7: 90%
  bucket 3: 80%
  bucket 4: 80%
  bucket 7: 100%
  bucket 4: 90%
  bucket 3: 90%
  bucket 5: 70%
  Sorting block of length 147 for bucket 7
  (Using difference cover)
  bucket 6: 20%
  bucket 2: 30%
  bucket 3: 100%
  bucket 4: 100%
  Sorting block of length 164 for bucket 3
  (Using difference cover)
  bucket 5: 80%
  bucket 2: 40%
  bucket 6: 30%
  bucket 2: 50%
  Sorting block of length 87 for bucket 4
  (Using difference cover)
  bucket 6: 40%
  bucket 5: 90%
  bucket 6: 50%
  bucket 5: 100%
  bucket 2: 60%
  bucket 6: 60%
  Sorting block of length 185 for bucket 5
  (Using difference cover)
  bucket 2: 70%
  bucket 6: 70%
  bucket 2: 80%
  bucket 6: 80%
  bucket 2: 90%
  bucket 6: 90%
  bucket 2: 100%
  Sorting block of length 175 for bucket 2
  (Using difference cover)
  bucket 6: 100%
  Sorting block of length 211 for bucket 6
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 174 for bucket 1
  Sorting block time: 00:00:00
Returning block of 88 for bucket 4
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 165 for bucket 3
Returning block of 186 for bucket 5
Returning block of 212 for bucket 6
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 176 for bucket 2
Returning block of 148 for bucket 7
Exited GFM loop
fchr[A]: 0
fchr[C]: 359
fchr[G]: 557
fchr[T]: 796
fchr[$]: 1148
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4194913 bytes to primary GFM file: MOCO_RNA_motif_index/MOCO_RNA_motif_index.1.ht2
Wrote 292 bytes to secondary GFM file: MOCO_RNA_motif_index/MOCO_RNA_motif_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 8677 bytes to primary GFM file: MOCO_RNA_motif_index/MOCO_RNA_motif_index.5.ht2
Wrote 292 bytes to secondary GFM file: MOCO_RNA_motif_index/MOCO_RNA_motif_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 1148
    gbwtLen: 1149
    nodes: 1149
    sz: 287
    gbwtSz: 288
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 72
    offsSz: 288
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 6
    numLines: 6
    gbwtTotLen: 384
    gbwtTotSz: 384
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "TPP_index/TPP_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  TPP.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 623 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 623 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 6; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 1; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 0; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 414.25 (target: 622)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 8
  Reserving size (623) for bucket 1
Getting block 2 of 8
  Reserving size (623) for bucket 2
  Calculating Z arrays for bucket 1
Getting block 3 of 8
  Calculating Z arrays for bucket 2
  Entering block accumulator loop for bucket 1:
  Reserving size (623) for bucket 3
  bucket 1: 10%
  Calculating Z arrays for bucket 3
  bucket 1: 20%
Getting block 5 of 8
  Entering block accumulator loop for bucket 2:
  Reserving size (623) for bucket 5
Getting block 6 of 8
  Reserving size (623) for bucket 6
  Calculating Z arrays for bucket 5
Getting block 4 of 8
  Reserving size (623) for bucket 4
  bucket 2: 10%
Getting block 8 of 8
  Entering block accumulator loop for bucket 5:
  bucket 1: 30%
  Calculating Z arrays for bucket 4
  bucket 2: 20%
  bucket 5: 10%
  Calculating Z arrays for bucket 6
  Entering block accumulator loop for bucket 3:
  bucket 1: 40%
  Reserving size (623) for bucket 8
  Entering block accumulator loop for bucket 6:
  Entering block accumulator loop for bucket 4:
  bucket 5: 20%
  bucket 2: 30%
  bucket 3: 10%
Getting block 7 of 8
  bucket 1: 50%
  bucket 6: 10%
  Calculating Z arrays for bucket 8
  bucket 1: 60%
  bucket 6: 20%
  bucket 3: 20%
  bucket 4: 10%
  bucket 6: 30%
  Entering block accumulator loop for bucket 8:
  bucket 3: 30%
  bucket 6: 40%
  Reserving size (623) for bucket 7
  bucket 2: 40%
  bucket 6: 50%
  bucket 3: 40%
  bucket 8: 10%
  bucket 2: 50%
  bucket 3: 50%
  bucket 6: 60%
  bucket 1: 70%
  bucket 2: 60%
  bucket 3: 60%
  bucket 5: 30%
  bucket 6: 70%
  bucket 2: 70%
  bucket 3: 70%
  bucket 6: 80%
  bucket 8: 20%
  bucket 5: 40%
  bucket 3: 80%
  bucket 2: 80%
  bucket 8: 30%
  bucket 6: 90%
  bucket 2: 90%
  bucket 8: 40%
  bucket 3: 90%
  bucket 2: 100%
  bucket 6: 100%
  bucket 4: 20%
  bucket 8: 50%
  bucket 5: 50%
  bucket 3: 100%
  bucket 1: 80%
  bucket 5: 60%
  Sorting block of length 583 for bucket 6
  (Using difference cover)
  bucket 1: 90%
  Sorting block of length 544 for bucket 2
  (Using difference cover)
  Sorting block of length 433 for bucket 3
  (Using difference cover)
  bucket 1: 100%
  Calculating Z arrays for bucket 7
  bucket 4: 30%
  bucket 8: 60%
  bucket 5: 70%
  bucket 4: 40%
  bucket 8: 70%
  bucket 5: 80%
  Sorting block of length 173 for bucket 1
  bucket 4: 50%
  (Using difference cover)
  bucket 5: 90%
  bucket 8: 80%
  bucket 4: 60%
  bucket 5: 100%
  Sorting block of length 602 for bucket 5
  (Using difference cover)
  bucket 4: 70%
  bucket 8: 90%
  bucket 4: 80%
  Entering block accumulator loop for bucket 7:
  bucket 8: 100%
  bucket 4: 90%
  Sorting block of length 492 for bucket 8
  (Using difference cover)
  bucket 7: 10%
  bucket 4: 100%
  Sorting block of length 216 for bucket 4
  (Using difference cover)
  bucket 7: 20%
  bucket 7: 30%
  bucket 7: 40%
  bucket 7: 50%
  bucket 7: 60%
  bucket 7: 70%
  bucket 7: 80%
  bucket 7: 90%
  bucket 7: 100%
  Sorting block of length 271 for bucket 7
  (Using difference cover)
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 434 for bucket 3
Returning block of 584 for bucket 6
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 217 for bucket 4
  Sorting block time: 00:00:00
Returning block of 174 for bucket 1
Returning block of 545 for bucket 2
  Sorting block time: 00:00:00
Returning block of 493 for bucket 8
  Sorting block time: 00:00:00
Returning block of 272 for bucket 7
  Sorting block time: 00:00:00
Returning block of 603 for bucket 5
Exited GFM loop
fchr[A]: 0
fchr[C]: 996
fchr[G]: 1588
fchr[T]: 2273
fchr[$]: 3321
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4195760 bytes to primary GFM file: TPP_index/TPP_index.1.ht2
Wrote 836 bytes to secondary GFM file: TPP_index/TPP_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 25781 bytes to primary GFM file: TPP_index/TPP_index.5.ht2
Wrote 840 bytes to secondary GFM file: TPP_index/TPP_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 3321
    gbwtLen: 3322
    nodes: 3322
    sz: 831
    gbwtSz: 831
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 208
    offsSz: 832
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 18
    numLines: 18
    gbwtTotLen: 1152
    gbwtTotSz: 1152
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "yybP-ykoY_index/yybP-ykoY_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  yybP-ykoY.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 211 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 211 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 6; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 0; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 139.875 (target: 210)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 8
Getting block 2 of 8
  Reserving size (211) for bucket 2
  Reserving size (211) for bucket 1
Getting block 3 of 8
  Calculating Z arrays for bucket 1
Getting block 4 of 8
  Reserving size (211) for bucket 4
  Calculating Z arrays for bucket 2
  Entering block accumulator loop for bucket 1:
Getting block 6 of 8
  Reserving size (211) for bucket 6
Getting block 7 of 8
  Reserving size (211) for bucket 3
  Entering block accumulator loop for bucket 2:
  Calculating Z arrays for bucket 3
Getting block 5 of 8
  Calculating Z arrays for bucket 4
Getting block 8 of 8
  Reserving size (211) for bucket 5
  Entering block accumulator loop for bucket 4:
  Calculating Z arrays for bucket 5
  Reserving size (211) for bucket 7
  Reserving size (211) for bucket 8
  Calculating Z arrays for bucket 7
  Calculating Z arrays for bucket 6
  bucket 2: 10%
  bucket 4: 10%
  Calculating Z arrays for bucket 8
  bucket 2: 20%
  Entering block accumulator loop for bucket 6:
  bucket 1: 10%
  Entering block accumulator loop for bucket 3:
  Entering block accumulator loop for bucket 8:
  bucket 4: 20%
  bucket 1: 20%
  Entering block accumulator loop for bucket 7:
  Entering block accumulator loop for bucket 5:
  bucket 6: 10%
  bucket 2: 30%
  bucket 4: 30%
  bucket 3: 10%
  bucket 2: 40%
  bucket 6: 20%
  bucket 5: 10%
  bucket 2: 50%
  bucket 4: 40%
  bucket 2: 60%
  bucket 6: 30%
  bucket 3: 20%
  bucket 1: 30%
  bucket 4: 50%
  bucket 3: 30%
  bucket 6: 40%
  bucket 8: 10%
  bucket 5: 20%
  bucket 1: 40%
  bucket 4: 60%
  bucket 1: 50%
  bucket 8: 20%
  bucket 5: 30%
  bucket 2: 70%
  bucket 5: 40%
  bucket 3: 40%
  bucket 1: 60%
  bucket 8: 30%
  bucket 6: 50%
  bucket 4: 70%
  bucket 7: 10%
  bucket 8: 40%
  bucket 6: 60%
  bucket 2: 80%
  bucket 4: 80%
  bucket 2: 90%
  bucket 6: 70%
  bucket 2: 100%
  bucket 3: 50%
  bucket 4: 90%
  bucket 6: 80%
  bucket 3: 60%
  bucket 8: 50%
  bucket 4: 100%
  Sorting block of length 198 for bucket 2
  (Using difference cover)
  bucket 5: 50%
  bucket 7: 20%
  bucket 8: 60%
  bucket 3: 70%
  bucket 6: 90%
  bucket 8: 70%
  bucket 6: 100%
  Sorting block of length 59 for bucket 6
  (Using difference cover)
  bucket 3: 80%
  Sorting block of length 197 for bucket 4
  bucket 5: 60%
  (Using difference cover)
  bucket 7: 30%
  bucket 5: 70%
  bucket 1: 70%
  bucket 3: 90%
  bucket 1: 80%
  bucket 7: 40%
  bucket 1: 90%
  bucket 3: 100%
  bucket 7: 50%
  Sorting block of length 34 for bucket 3
  bucket 5: 80%
  (Using difference cover)
  bucket 8: 80%
  bucket 1: 100%
  bucket 7: 60%
  bucket 8: 90%
  Sorting block of length 148 for bucket 1
  (Using difference cover)
  bucket 8: 100%
  bucket 7: 70%
  bucket 5: 90%
  bucket 7: 80%
  Sorting block of length 148 for bucket 8
  (Using difference cover)
  bucket 7: 90%
  bucket 5: 100%
  Sorting block of length 153 for bucket 5
  (Using difference cover)
  bucket 7: 100%
  Sorting block of length 182 for bucket 7
  (Using difference cover)
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 199 for bucket 2
Returning block of 198 for bucket 4
  Sorting block time: 00:00:00
Returning block of 149 for bucket 1
  Sorting block time: 00:00:00
Returning block of 60 for bucket 6
  Sorting block time: 00:00:00
Returning block of 154 for bucket 5
  Sorting block time: 00:00:00
Returning block of 35 for bucket 3
  Sorting block time: 00:00:00
Returning block of 149 for bucket 8
  Sorting block time: 00:00:00
Returning block of 183 for bucket 7
Exited GFM loop
fchr[A]: 0
fchr[C]: 354
fchr[G]: 574
fchr[T]: 781
fchr[$]: 1126
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4194908 bytes to primary GFM file: yybP-ykoY_index/yybP-ykoY_index.1.ht2
Wrote 288 bytes to secondary GFM file: yybP-ykoY_index/yybP-ykoY_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 8677 bytes to primary GFM file: yybP-ykoY_index/yybP-ykoY_index.5.ht2
Wrote 286 bytes to secondary GFM file: yybP-ykoY_index/yybP-ykoY_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 1126
    gbwtLen: 1127
    nodes: 1127
    sz: 282
    gbwtSz: 282
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 71
    offsSz: 284
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 6
    numLines: 6
    gbwtTotLen: 384
    gbwtTotSz: 384
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:01
Settings:
  Output files: "TPP_index/TPP_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  TPP.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 624 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 624 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 2, merged 6; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 474 (target: 623)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 7
  Reserving size (624) for bucket 1
  Calculating Z arrays for bucket 1
Getting block 2 of 7
Getting block 3 of 7
Getting block 5 of 7
Getting block 6 of 7
Getting block 7 of 7
  Reserving size (624) for bucket 7
  Reserving size (624) for bucket 3
  Reserving size (624) for bucket 5
  Calculating Z arrays for bucket 7
  Reserving size (624) for bucket 2
  Calculating Z arrays for bucket 3
  Calculating Z arrays for bucket 2
  Calculating Z arrays for bucket 5
  Entering block accumulator loop for bucket 1:
  Entering block accumulator loop for bucket 7:
  bucket 1: 10%
Getting block 4 of 7
  Entering block accumulator loop for bucket 2:
  bucket 7: 10%
  Entering block accumulator loop for bucket 3:
  bucket 1: 20%
  Reserving size (624) for bucket 6
  Entering block accumulator loop for bucket 5:
  bucket 3: 10%
  bucket 7: 20%
  Reserving size (624) for bucket 4
  bucket 1: 30%
  bucket 2: 10%
  bucket 5: 10%
  bucket 7: 30%
  bucket 1: 40%
  bucket 2: 20%
  bucket 3: 20%
  bucket 7: 40%
  Calculating Z arrays for bucket 6
  bucket 3: 30%
  Calculating Z arrays for bucket 4
  bucket 7: 50%
  bucket 3: 40%
  bucket 1: 50%
  bucket 2: 30%
  bucket 7: 60%
  bucket 1: 60%
  bucket 5: 20%
  bucket 7: 70%
  Entering block accumulator loop for bucket 6:
  bucket 1: 70%
  bucket 5: 30%
  bucket 2: 40%
  bucket 6: 10%
  bucket 7: 80%
  bucket 5: 40%
  bucket 6: 20%
  bucket 2: 50%
  bucket 1: 80%
  Entering block accumulator loop for bucket 4:
  bucket 1: 90%
  bucket 5: 50%
  bucket 3: 50%
  bucket 6: 30%
  bucket 7: 90%
  bucket 4: 10%
  bucket 3: 60%
  bucket 5: 60%
  bucket 1: 100%
  bucket 2: 60%
  Sorting block of length 603 for bucket 1
  (Using difference cover)
  bucket 5: 70%
  bucket 3: 70%
  bucket 4: 20%
  bucket 2: 70%
  bucket 5: 80%
  bucket 6: 40%
  bucket 3: 80%
  bucket 4: 30%
  bucket 7: 100%
  bucket 5: 90%
  bucket 2: 80%
  bucket 3: 90%
  bucket 4: 40%
  bucket 5: 100%
  bucket 6: 50%
  Sorting block of length 613 for bucket 5
  (Using difference cover)
  bucket 2: 90%
  bucket 3: 100%
  bucket 4: 50%
  Sorting block of length 548 for bucket 7
  (Using difference cover)
  bucket 6: 60%
  bucket 2: 100%
  Sorting block of length 401 for bucket 2
  (Using difference cover)
  bucket 4: 60%
  Sorting block of length 524 for bucket 3
  (Using difference cover)
  bucket 6: 70%
  bucket 4: 70%
  bucket 6: 80%
  bucket 4: 80%
  bucket 6: 90%
  bucket 4: 90%
  bucket 6: 100%
  Sorting block of length 125 for bucket 6
  (Using difference cover)
  bucket 4: 100%
  Sorting block of length 504 for bucket 4
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 126 for bucket 6
  Sorting block time: 00:00:00
Returning block of 604 for bucket 1
  Sorting block time: 00:00:00
Returning block of 614 for bucket 5
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 402 for bucket 2
Returning block of 505 for bucket 4
Returning block of 525 for bucket 3
  Sorting block time: 00:00:00
Returning block of 549 for bucket 7
Exited GFM loop
fchr[A]: 0
fchr[C]: 774
fchr[G]: 1688
fchr[T]: 2524
fchr[$]: 3324
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4195766 bytes to primary GFM file: TPP_index/TPP_index.1.ht2
Wrote 836 bytes to secondary GFM file: TPP_index/TPP_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 25845 bytes to primary GFM file: TPP_index/TPP_index.5.ht2
Wrote 840 bytes to secondary GFM file: TPP_index/TPP_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 3324
    gbwtLen: 3325
    nodes: 3325
    sz: 831
    gbwtSz: 832
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 208
    offsSz: 832
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 18
    numLines: 18
    gbwtTotLen: 1152
    gbwtTotSz: 1152
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "Cobalamin_index/Cobalamin_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  Cobalamin.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 1350 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 1350 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 2, merged 7; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 0; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 1; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 1028.14 (target: 1349)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 7
  Reserving size (1350) for bucket 1
Getting block 2 of 7
  Reserving size (1350) for bucket 2
  Calculating Z arrays for bucket 1
  Calculating Z arrays for bucket 2
Getting block 3 of 7
  Reserving size (1350) for bucket 3
  Entering block accumulator loop for bucket 1:
  Calculating Z arrays for bucket 3
  Entering block accumulator loop for bucket 2:
  bucket 1: 10%
Getting block 4 of 7
  bucket 1: 20%
Getting block 5 of 7
  Reserving size (1350) for bucket 5
Getting block 6 of 7
  Reserving size (1350) for bucket 6
  Reserving size (1350) for bucket 4
  Entering block accumulator loop for bucket 3:
  Calculating Z arrays for bucket 5
Getting block 7 of 7
  Reserving size (1350) for bucket 7
  Calculating Z arrays for bucket 4
  bucket 3: 10%
  bucket 2: 10%
  Calculating Z arrays for bucket 6
  Entering block accumulator loop for bucket 5:
  Calculating Z arrays for bucket 7
  bucket 3: 20%
  bucket 5: 10%
  Entering block accumulator loop for bucket 6:
  bucket 1: 30%
  bucket 3: 30%
  Entering block accumulator loop for bucket 7:
  Entering block accumulator loop for bucket 4:
  bucket 2: 20%
  bucket 5: 20%
  bucket 6: 10%
  bucket 1: 40%
  bucket 3: 40%
  bucket 4: 10%
  bucket 2: 30%
  bucket 1: 50%
  bucket 5: 30%
  bucket 6: 20%
  bucket 3: 50%
  bucket 7: 10%
  bucket 2: 40%
  bucket 1: 60%
  bucket 4: 20%
  bucket 6: 30%
  bucket 5: 40%
  bucket 7: 20%
  bucket 2: 50%
  bucket 3: 60%
  bucket 4: 30%
  bucket 1: 70%
  bucket 6: 40%
  bucket 5: 50%
  bucket 7: 30%
  bucket 3: 70%
  bucket 1: 80%
  bucket 2: 60%
  bucket 4: 40%
  bucket 6: 50%
  bucket 7: 40%
  bucket 5: 60%
  bucket 1: 90%
  bucket 3: 80%
  bucket 2: 70%
  bucket 4: 50%
  bucket 7: 50%
  bucket 1: 100%
  bucket 6: 60%
  Sorting block of length 1050 for bucket 1
  (Using difference cover)
  bucket 3: 90%
  bucket 4: 60%
  bucket 2: 80%
  bucket 7: 60%
  bucket 5: 70%
  bucket 6: 70%
  bucket 3: 100%
  bucket 4: 70%
  Sorting block of length 830 for bucket 3
  (Using difference cover)
  bucket 7: 70%
  bucket 4: 80%
  bucket 6: 80%
  bucket 2: 90%
  bucket 5: 80%
  bucket 7: 80%
  bucket 4: 90%
  bucket 6: 90%
  bucket 2: 100%
  Sorting block of length 1120 for bucket 2
  (Using difference cover)
  bucket 4: 100%
  bucket 5: 90%
  Sorting block of length 963 for bucket 4
  (Using difference cover)
  bucket 6: 100%
  bucket 7: 90%
  Sorting block of length 694 for bucket 6
  (Using difference cover)
  bucket 5: 100%
  Sorting block of length 1312 for bucket 5
  (Using difference cover)
  bucket 7: 100%
  Sorting block of length 1228 for bucket 7
  (Using difference cover)
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 831 for bucket 3
  Sorting block time: 00:00:00
Returning block of 695 for bucket 6
Returning block of 1051 for bucket 1
Returning block of 1313 for bucket 5
Returning block of 964 for bucket 4
Returning block of 1121 for bucket 2
Returning block of 1229 for bucket 7
Exited GFM loop
fchr[A]: 0
fchr[C]: 2159
fchr[G]: 3633
fchr[T]: 5177
fchr[$]: 7203
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4197231 bytes to primary GFM file: Cobalamin_index/Cobalamin_index.1.ht2
Wrote 1808 bytes to secondary GFM file: Cobalamin_index/Cobalamin_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 51917 bytes to primary GFM file: Cobalamin_index/Cobalamin_index.5.ht2
Wrote 1810 bytes to secondary GFM file: Cobalamin_index/Cobalamin_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 7203
    gbwtLen: 7204
    nodes: 7204
    sz: 1801
    gbwtSz: 1802
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 451
    offsSz: 1804
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 38
    numLines: 38
    gbwtTotLen: 2432
    gbwtTotSz: 2432
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "Fluoride_index/Fluoride_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  Fluoride.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 199 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 199 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 6; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 1; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 150.857 (target: 198)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 7
  Reserving size (199) for bucket 1
Getting block 2 of 7
  Calculating Z arrays for bucket 1
Getting block 3 of 7
  Reserving size (199) for bucket 3
Getting block 4 of 7
  Reserving size (199) for bucket 2
Getting block 7 of 7
  Entering block accumulator loop for bucket 1:
  Calculating Z arrays for bucket 2
  Calculating Z arrays for bucket 3
  Reserving size (199) for bucket 7
Getting block 5 of 7
  Reserving size (199) for bucket 5
  Calculating Z arrays for bucket 7
  Calculating Z arrays for bucket 5
  Entering block accumulator loop for bucket 2:
  Reserving size (199) for bucket 4
  bucket 2: 10%
  Entering block accumulator loop for bucket 5:
Getting block 6 of 7
  bucket 2: 20%
  Entering block accumulator loop for bucket 7:
  Calculating Z arrays for bucket 4
  bucket 1: 10%
  Entering block accumulator loop for bucket 3:
  bucket 7: 10%
  bucket 5: 10%
  bucket 7: 20%
  bucket 2: 30%
  bucket 1: 20%
  bucket 7: 30%
  bucket 5: 20%
  bucket 2: 40%
  Entering block accumulator loop for bucket 4:
  bucket 2: 50%
  bucket 7: 40%
  Reserving size (199) for bucket 6
  bucket 5: 30%
  bucket 2: 60%
  bucket 3: 10%
  bucket 5: 40%
  bucket 3: 20%
  bucket 5: 50%
  bucket 2: 70%
  Calculating Z arrays for bucket 6
  bucket 4: 10%
  bucket 5: 60%
  bucket 3: 30%
  bucket 5: 70%
  bucket 4: 20%
  bucket 1: 30%
  bucket 3: 40%
  bucket 2: 80%
  bucket 4: 30%
  bucket 1: 40%
  Entering block accumulator loop for bucket 6:
  bucket 5: 80%
  bucket 7: 50%
  bucket 2: 90%
  bucket 1: 50%
  bucket 2: 100%
  bucket 3: 50%
  bucket 1: 60%
  Sorting block of length 164 for bucket 2
  (Using difference cover)
  bucket 7: 60%
  bucket 3: 60%
  bucket 4: 40%
  bucket 1: 70%
  bucket 7: 70%
  bucket 4: 50%
  bucket 7: 80%
  bucket 3: 70%
  bucket 4: 60%
  bucket 7: 90%
  bucket 1: 80%
  bucket 3: 80%
  bucket 7: 100%
  bucket 5: 90%
  Sorting block of length 68 for bucket 7
  bucket 5: 100%
  (Using difference cover)
  bucket 3: 90%
  bucket 6: 10%
  bucket 4: 70%
  Sorting block of length 68 for bucket 5
  (Using difference cover)
  bucket 4: 80%
  bucket 1: 90%
  bucket 4: 90%
  bucket 3: 100%
  bucket 6: 20%
  bucket 4: 100%
  bucket 6: 30%
  bucket 1: 100%
  Sorting block of length 183 for bucket 1
  (Using difference cover)
  Sorting block of length 185 for bucket 3
  (Using difference cover)
  Sorting block of length 193 for bucket 4
  (Using difference cover)
  bucket 6: 40%
  bucket 6: 50%
  bucket 6: 60%
  bucket 6: 70%
  bucket 6: 80%
  bucket 6: 90%
  bucket 6: 100%
  Sorting block of length 195 for bucket 6
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 165 for bucket 2
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 196 for bucket 6
Returning block of 69 for bucket 7
Returning block of 184 for bucket 1
Returning block of 69 for bucket 5
Returning block of 186 for bucket 3
Returning block of 194 for bucket 4
Exited GFM loop
fchr[A]: 0
fchr[C]: 304
fchr[G]: 546
fchr[T]: 750
fchr[$]: 1062
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4194907 bytes to primary GFM file: Fluoride_index/Fluoride_index.1.ht2
Wrote 272 bytes to secondary GFM file: Fluoride_index/Fluoride_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 8613 bytes to primary GFM file: Fluoride_index/Fluoride_index.5.ht2
Wrote 270 bytes to secondary GFM file: Fluoride_index/Fluoride_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 1062
    gbwtLen: 1063
    nodes: 1063
    sz: 266
    gbwtSz: 266
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 67
    offsSz: 268
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 6
    numLines: 6
    gbwtTotLen: 384
    gbwtTotSz: 384
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "TPP_index/TPP_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  TPP.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 616 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 616 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 2, merged 6; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 1; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 409.875 (target: 615)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 8
  Reserving size (616) for bucket 1
Getting block 2 of 8
  Reserving size (616) for bucket 2
Getting block 3 of 8
  Reserving size (616) for bucket 3
  Calculating Z arrays for bucket 1
  Calculating Z arrays for bucket 3
  Calculating Z arrays for bucket 2
Getting block 4 of 8
  Reserving size (616) for bucket 4
  Entering block accumulator loop for bucket 3:
  Entering block accumulator loop for bucket 1:
  Calculating Z arrays for bucket 4
Getting block 6 of 8
  bucket 1: 10%
  Entering block accumulator loop for bucket 2:
Getting block 5 of 8
  bucket 1: 20%
  bucket 3: 10%
  Entering block accumulator loop for bucket 4:
Getting block 7 of 8
  Reserving size (616) for bucket 6
  bucket 1: 30%
  bucket 2: 10%
  Reserving size (616) for bucket 7
  bucket 3: 20%
  bucket 1: 40%
  Calculating Z arrays for bucket 6
  bucket 2: 20%
  Reserving size (616) for bucket 5
  bucket 3: 30%
Getting block 8 of 8
  Calculating Z arrays for bucket 5
  bucket 2: 30%
  Reserving size (616) for bucket 8
  Entering block accumulator loop for bucket 6:
  Calculating Z arrays for bucket 7
  bucket 2: 40%
  Calculating Z arrays for bucket 8
  bucket 6: 10%
  bucket 2: 50%
  bucket 1: 50%
  bucket 3: 40%
  bucket 6: 20%
  bucket 4: 10%
  Entering block accumulator loop for bucket 8:
  bucket 1: 60%
  Entering block accumulator loop for bucket 7:
  bucket 8: 10%
  bucket 4: 20%
  bucket 1: 70%
  Entering block accumulator loop for bucket 5:
  bucket 3: 50%
  bucket 6: 30%
  bucket 4: 30%
  bucket 1: 80%
  bucket 8: 20%
  bucket 2: 60%
  bucket 6: 40%
  bucket 7: 10%
  bucket 8: 30%
  bucket 3: 60%
  bucket 4: 40%
  bucket 1: 90%
  bucket 7: 20%
  bucket 2: 70%
  bucket 4: 50%
  bucket 3: 70%
  bucket 8: 40%
  bucket 7: 30%
  bucket 1: 100%
  bucket 3: 80%
  bucket 4: 60%
  bucket 5: 10%
  Sorting block of length 532 for bucket 1
  (Using difference cover)
  bucket 3: 90%
  bucket 2: 80%
  bucket 8: 50%
  bucket 6: 50%
  bucket 4: 70%
  bucket 3: 100%
  bucket 5: 20%
  Sorting block of length 560 for bucket 3
  (Using difference cover)
  bucket 4: 80%
  bucket 6: 60%
  bucket 7: 40%
  bucket 5: 30%
  bucket 8: 60%
  bucket 4: 90%
  bucket 6: 70%
  bucket 2: 90%
  bucket 7: 50%
  bucket 5: 40%
  bucket 2: 100%
  bucket 8: 70%
  bucket 4: 100%
  bucket 7: 60%
  bucket 6: 80%
  bucket 5: 50%
  bucket 8: 80%
  bucket 7: 70%
  bucket 6: 90%
  Sorting block of length 195 for bucket 2
  (Using difference cover)
  Sorting block of length 254 for bucket 4
  (Using difference cover)
  bucket 7: 80%
  bucket 5: 60%
  bucket 6: 100%
  bucket 8: 90%
  bucket 7: 90%
  bucket 5: 70%
  bucket 8: 100%
  Sorting block of length 526 for bucket 6
  (Using difference cover)
  bucket 7: 100%
  Sorting block of length 386 for bucket 8
  (Using difference cover)
  Sorting block of length 436 for bucket 7
  (Using difference cover)
  bucket 5: 80%
  bucket 5: 90%
  bucket 5: 100%
  Sorting block of length 390 for bucket 5
  (Using difference cover)
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 196 for bucket 2
  Sorting block time: 00:00:00
Returning block of 533 for bucket 1
Returning block of 255 for bucket 4
  Sorting block time: 00:00:00
Returning block of 561 for bucket 3
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 527 for bucket 6
  Sorting block time: 00:00:00
Returning block of 437 for bucket 7
Returning block of 387 for bucket 8
  Sorting block time: 00:00:00
Returning block of 391 for bucket 5
Exited GFM loop
fchr[A]: 0
fchr[C]: 983
fchr[G]: 1711
fchr[T]: 2468
fchr[$]: 3286
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4195764 bytes to primary GFM file: TPP_index/TPP_index.1.ht2
Wrote 828 bytes to secondary GFM file: TPP_index/TPP_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 25781 bytes to primary GFM file: TPP_index/TPP_index.5.ht2
Wrote 828 bytes to secondary GFM file: TPP_index/TPP_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 3286
    gbwtLen: 3287
    nodes: 3287
    sz: 822
    gbwtSz: 822
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 206
    offsSz: 824
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 18
    numLines: 18
    gbwtTotLen: 1152
    gbwtTotSz: 1152
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "Cobalamin_index/Cobalamin_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  Cobalamin.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 453 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 453 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 11 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 7; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 0; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 0; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 344.143 (target: 452)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 7
  Reserving size (453) for bucket 1
Getting block 2 of 7
  Reserving size (453) for bucket 2
Getting block 3 of 7
  Reserving size (453) for bucket 3
  Calculating Z arrays for bucket 1
Getting block 5 of 7
  Calculating Z arrays for bucket 2
  Entering block accumulator loop for bucket 1:
Getting block 4 of 7
Getting block 6 of 7
  Calculating Z arrays for bucket 3
  Reserving size (453) for bucket 5
  Reserving size (453) for bucket 6
  Calculating Z arrays for bucket 5
Getting block 7 of 7
  bucket 1: 10%
  Reserving size (453) for bucket 4
  Calculating Z arrays for bucket 6
  Calculating Z arrays for bucket 4
  Entering block accumulator loop for bucket 5:
  bucket 1: 20%
  Entering block accumulator loop for bucket 2:
  Entering block accumulator loop for bucket 3:
  bucket 5: 10%
  Reserving size (453) for bucket 7
  bucket 2: 10%
  bucket 5: 20%
  bucket 1: 30%
  bucket 3: 10%
  bucket 5: 30%
  bucket 2: 20%
  Calculating Z arrays for bucket 7
  bucket 5: 40%
  bucket 2: 30%
  Entering block accumulator loop for bucket 4:
  bucket 5: 50%
  Entering block accumulator loop for bucket 7:
  bucket 3: 20%
  bucket 2: 40%
  bucket 5: 60%
  bucket 1: 40%
  bucket 7: 10%
  bucket 2: 50%
  bucket 5: 70%
  bucket 3: 30%
  bucket 4: 10%
  bucket 2: 60%
  bucket 3: 40%
  Entering block accumulator loop for bucket 6:
  bucket 2: 70%
  bucket 5: 80%
  bucket 6: 10%
  bucket 1: 50%
  bucket 3: 50%
  bucket 6: 20%
  bucket 2: 80%
  bucket 3: 60%
  bucket 5: 90%
  bucket 6: 30%
  bucket 1: 60%
  bucket 4: 20%
  bucket 6: 40%
  bucket 5: 100%
  bucket 2: 90%
  bucket 7: 20%
  Sorting block of length 382 for bucket 5
  (Using difference cover)
  bucket 2: 100%
  bucket 1: 70%
  bucket 4: 30%
  bucket 3: 70%
  bucket 6: 50%
  Sorting block of length 452 for bucket 2
  bucket 3: 80%
  bucket 7: 30%
  (Using difference cover)
  bucket 3: 90%
  bucket 1: 80%
  bucket 4: 40%
  bucket 7: 40%
  bucket 6: 60%
  bucket 1: 90%
  bucket 7: 50%
  bucket 4: 50%
  bucket 1: 100%
  bucket 3: 100%
  bucket 6: 70%
  bucket 7: 60%
  Sorting block of length 422 for bucket 3
  (Using difference cover)
  bucket 4: 60%
  bucket 7: 70%
  bucket 6: 80%
  bucket 4: 70%
  Sorting block of length 156 for bucket 1
  (Using difference cover)
  bucket 6: 90%
  bucket 4: 80%
  bucket 7: 80%
  bucket 4: 90%
  bucket 6: 100%
  bucket 4: 100%
  Sorting block of length 273 for bucket 4
  (Using difference cover)
  Sorting block of length 398 for bucket 6
  (Using difference cover)
  bucket 7: 90%
  bucket 7: 100%
  Sorting block of length 326 for bucket 7
  (Using difference cover)
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 383 for bucket 5
  Sorting block time: 00:00:00
Returning block of 453 for bucket 2
Returning block of 157 for bucket 1
Returning block of 423 for bucket 3
  Sorting block time: 00:00:00
Returning block of 274 for bucket 4
  Sorting block time: 00:00:00
Returning block of 399 for bucket 6
  Sorting block time: 00:00:00
Returning block of 327 for bucket 7
Exited GFM loop
fchr[A]: 0
fchr[C]: 397
fchr[G]: 1230
fchr[T]: 2046
fchr[$]: 2415
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4195409 bytes to primary GFM file: Cobalamin_index/Cobalamin_index.1.ht2
Wrote 608 bytes to secondary GFM file: Cobalamin_index/Cobalamin_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 17325 bytes to primary GFM file: Cobalamin_index/Cobalamin_index.5.ht2
Wrote 610 bytes to secondary GFM file: Cobalamin_index/Cobalamin_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 2415
    gbwtLen: 2416
    nodes: 2416
    sz: 604
    gbwtSz: 605
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 151
    offsSz: 604
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 13
    numLines: 13
    gbwtTotLen: 832
    gbwtTotSz: 832
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "Glycine_index/Glycine_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  Glycine.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 408 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 408 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 6; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 1; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 0; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 271.375 (target: 407)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 8
  Reserving size (408) for bucket 1
Getting block 2 of 8
  Reserving size (408) for bucket 2
Getting block 3 of 8
  Reserving size (408) for bucket 3
  Calculating Z arrays for bucket 2
  Calculating Z arrays for bucket 3
  Calculating Z arrays for bucket 1
Getting block 4 of 8
  Entering block accumulator loop for bucket 1:
Getting block 6 of 8
  Reserving size (408) for bucket 6
  Entering block accumulator loop for bucket 2:
  Entering block accumulator loop for bucket 3:
  Calculating Z arrays for bucket 6
Getting block 5 of 8
  bucket 1: 10%
  Reserving size (408) for bucket 4
  bucket 1: 20%
  Reserving size (408) for bucket 5
  bucket 2: 10%
  bucket 1: 30%
  bucket 3: 10%
  Entering block accumulator loop for bucket 6:
  bucket 2: 20%
  bucket 3: 20%
Getting block 7 of 8
  Calculating Z arrays for bucket 5
  bucket 6: 10%
  bucket 3: 30%
  bucket 1: 40%
Getting block 8 of 8
  bucket 2: 30%
  Reserving size (408) for bucket 8
  bucket 3: 40%
  Calculating Z arrays for bucket 4
  bucket 2: 40%
  bucket 6: 20%
  bucket 2: 50%
  Calculating Z arrays for bucket 8
  bucket 2: 60%
  Reserving size (408) for bucket 7
  bucket 1: 50%
  Entering block accumulator loop for bucket 5:
  bucket 2: 70%
  Entering block accumulator loop for bucket 8:
  Entering block accumulator loop for bucket 4:
  bucket 1: 60%
  bucket 3: 50%
  Calculating Z arrays for bucket 7
  bucket 1: 70%
  bucket 3: 60%
  bucket 8: 10%
  bucket 1: 80%
  bucket 3: 70%
  bucket 5: 10%
  bucket 8: 20%
  bucket 3: 80%
  bucket 8: 30%
  bucket 6: 30%
  bucket 3: 90%
  bucket 5: 20%
  bucket 1: 90%
  bucket 8: 40%
  bucket 6: 40%
  bucket 1: 100%
  bucket 4: 10%
  bucket 3: 100%
  Entering block accumulator loop for bucket 7:
  bucket 8: 50%
  bucket 2: 80%
  bucket 6: 50%
  bucket 5: 30%
  Sorting block of length 258 for bucket 1
  (Using difference cover)
  bucket 6: 60%
  bucket 4: 20%
  bucket 7: 10%
  bucket 8: 60%
  bucket 2: 90%
  bucket 7: 20%
  bucket 6: 70%
  Sorting block of length 227 for bucket 3
  (Using difference cover)
  bucket 7: 30%
  bucket 2: 100%
  bucket 8: 70%
  bucket 4: 30%
  Sorting block of length 221 for bucket 2
  (Using difference cover)
  bucket 6: 80%
  bucket 4: 40%
  bucket 7: 40%
  bucket 5: 40%
  bucket 6: 90%
  bucket 7: 50%
  bucket 4: 50%
  bucket 8: 80%
  bucket 5: 50%
  bucket 8: 90%
  bucket 4: 60%
  bucket 6: 100%
  bucket 5: 60%
  bucket 7: 60%
  bucket 8: 100%
  Sorting block of length 160 for bucket 8
  bucket 7: 70%
  bucket 4: 70%
  (Using difference cover)
  bucket 5: 70%
  bucket 7: 80%
  bucket 4: 80%
  Sorting block of length 310 for bucket 6
  bucket 7: 90%
  bucket 4: 90%
  (Using difference cover)
  bucket 5: 80%
  bucket 7: 100%
  bucket 4: 100%
  Sorting block of length 385 for bucket 4
  bucket 5: 90%
  Sorting block of length 339 for bucket 7
  (Using difference cover)
  bucket 5: 100%
  Sorting block of length 271 for bucket 5
  (Using difference cover)
  (Using difference cover)
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 259 for bucket 1
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 228 for bucket 3
Returning block of 161 for bucket 8
Returning block of 311 for bucket 6
Returning block of 222 for bucket 2
Returning block of 340 for bucket 7
  Sorting block time: 00:00:00
Returning block of 272 for bucket 5
  Sorting block time: 00:00:00
Returning block of 386 for bucket 4
Exited GFM loop
fchr[A]: 0
fchr[C]: 409
fchr[G]: 1094
fchr[T]: 1795
fchr[$]: 2178
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4195343 bytes to primary GFM file: Glycine_index/Glycine_index.1.ht2
Wrote 552 bytes to secondary GFM file: Glycine_index/Glycine_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 17197 bytes to primary GFM file: Glycine_index/Glycine_index.5.ht2
Wrote 552 bytes to secondary GFM file: Glycine_index/Glycine_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 2178
    gbwtLen: 2179
    nodes: 2179
    sz: 545
    gbwtSz: 545
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 137
    offsSz: 548
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 12
    numLines: 12
    gbwtTotLen: 768
    gbwtTotSz: 768
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "nhaA-I_index/nhaA-I_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  nhaA-I.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 198 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 198 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 7; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 174.5 (target: 197)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 6
  Reserving size (198) for bucket 1
Getting block 2 of 6
Getting block 3 of 6
  Reserving size (198) for bucket 2
Getting block 5 of 6
  Reserving size (198) for bucket 5
  Calculating Z arrays for bucket 2
  Calculating Z arrays for bucket 5
Getting block 4 of 6
  Calculating Z arrays for bucket 1
  Reserving size (198) for bucket 4
  Entering block accumulator loop for bucket 5:
  Entering block accumulator loop for bucket 1:
  bucket 5: 10%
Getting block 6 of 6
  Entering block accumulator loop for bucket 2:
  Reserving size (198) for bucket 3
  bucket 1: 10%
  bucket 2: 10%
  Calculating Z arrays for bucket 3
  Calculating Z arrays for bucket 4
  bucket 1: 20%
  bucket 2: 20%
  bucket 1: 30%
  bucket 5: 20%
  bucket 1: 40%
  bucket 2: 30%
  bucket 1: 50%
  bucket 5: 30%
  bucket 1: 60%
  bucket 5: 40%
  Entering block accumulator loop for bucket 3:
  Entering block accumulator loop for bucket 4:
  bucket 1: 70%
  bucket 2: 40%
  bucket 1: 80%
  bucket 3: 10%
  bucket 2: 50%
  Reserving size (198) for bucket 6
  bucket 3: 20%
  bucket 1: 90%
  bucket 5: 50%
  bucket 2: 60%
  bucket 3: 30%
  bucket 2: 70%
  bucket 1: 100%
  bucket 5: 60%
  bucket 4: 10%
  bucket 2: 80%
  Sorting block of length 195 for bucket 1
  (Using difference cover)
  bucket 2: 90%
  bucket 3: 40%
  bucket 4: 20%
  bucket 2: 100%
  bucket 4: 30%
  bucket 3: 50%
  bucket 5: 70%
  bucket 4: 40%
  bucket 5: 80%
  Calculating Z arrays for bucket 6
  bucket 3: 60%
  bucket 5: 90%
  bucket 4: 50%
  bucket 5: 100%
  Sorting block of length 186 for bucket 2
  (Using difference cover)
  Sorting block of length 161 for bucket 5
  (Using difference cover)
  bucket 4: 60%
  bucket 3: 70%
  bucket 4: 70%
  bucket 3: 80%
  bucket 4: 80%
  bucket 3: 90%
  bucket 4: 90%
  bucket 3: 100%
  bucket 4: 100%
  Sorting block of length 178 for bucket 4
  (Using difference cover)
  Sorting block of length 164 for bucket 3
  (Using difference cover)
  Entering block accumulator loop for bucket 6:
  bucket 6: 10%
  bucket 6: 20%
  bucket 6: 30%
  bucket 6: 40%
  bucket 6: 50%
  bucket 6: 60%
  bucket 6: 70%
  bucket 6: 80%
  bucket 6: 90%
  bucket 6: 100%
  Sorting block of length 163 for bucket 6
  (Using difference cover)
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 196 for bucket 1
  Sorting block time: 00:00:00
Returning block of 165 for bucket 3
Returning block of 187 for bucket 2
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 162 for bucket 5
Returning block of 179 for bucket 4
  Sorting block time: 00:00:00
Returning block of 164 for bucket 6
Exited GFM loop
fchr[A]: 0
fchr[C]: 139
fchr[G]: 518
fchr[T]: 863
fchr[$]: 1052
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4194903 bytes to primary GFM file: nhaA-I_index/nhaA-I_index.1.ht2
Wrote 268 bytes to secondary GFM file: nhaA-I_index/nhaA-I_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 8613 bytes to primary GFM file: nhaA-I_index/nhaA-I_index.5.ht2
Wrote 268 bytes to secondary GFM file: nhaA-I_index/nhaA-I_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 1052
    gbwtLen: 1053
    nodes: 1053
    sz: 263
    gbwtSz: 264
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 66
    offsSz: 264
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 6
    numLines: 6
    gbwtTotLen: 384
    gbwtTotSz: 384
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:01
Settings:
  Output files: "TPP_index/TPP_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  TPP.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 207 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 207 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 6; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 157 (target: 206)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 7
  Reserving size (207) for bucket 1
Getting block 2 of 7
  Reserving size (207) for bucket 2
Getting block 3 of 7
  Reserving size (207) for bucket 3
  Calculating Z arrays for bucket 2
Getting block 4 of 7
  Reserving size (207) for bucket 4
  Calculating Z arrays for bucket 1
Getting block 5 of 7
  Entering block accumulator loop for bucket 2:
  Calculating Z arrays for bucket 3
  Reserving size (207) for bucket 5
Getting block 6 of 7
Getting block 7 of 7
  Entering block accumulator loop for bucket 1:
  Entering block accumulator loop for bucket 3:
  Reserving size (207) for bucket 6
  Reserving size (207) for bucket 7
  Calculating Z arrays for bucket 4
  Calculating Z arrays for bucket 5
  Calculating Z arrays for bucket 6
  bucket 2: 10%
  Calculating Z arrays for bucket 7
  bucket 3: 10%
  bucket 2: 20%
  Entering block accumulator loop for bucket 5:
  bucket 3: 20%
  Entering block accumulator loop for bucket 7:
  bucket 5: 10%
  bucket 3: 30%
  bucket 2: 30%
  bucket 3: 40%
  Entering block accumulator loop for bucket 4:
  Entering block accumulator loop for bucket 6:
  bucket 2: 40%
  bucket 3: 50%
  bucket 4: 10%
  bucket 3: 60%
  bucket 2: 50%
  bucket 4: 20%
  bucket 6: 10%
  bucket 1: 10%
  bucket 5: 20%
  bucket 1: 20%
  bucket 7: 10%
  bucket 4: 30%
  bucket 3: 70%
  bucket 6: 20%
  bucket 4: 40%
  bucket 2: 60%
  bucket 6: 30%
  bucket 5: 30%
  bucket 7: 20%
  bucket 4: 50%
  bucket 7: 30%
  bucket 2: 70%
  bucket 4: 60%
  bucket 1: 30%
  bucket 4: 70%
  bucket 2: 80%
  bucket 5: 40%
  bucket 4: 80%
  bucket 7: 40%
  bucket 5: 50%
  bucket 1: 40%
  bucket 6: 40%
  bucket 5: 60%
  bucket 4: 90%
  bucket 1: 50%
  bucket 5: 70%
  bucket 3: 80%
  bucket 4: 100%
  bucket 6: 50%
  bucket 5: 80%
  bucket 3: 90%
  bucket 1: 60%
  bucket 5: 90%
  bucket 3: 100%
  bucket 6: 60%
  bucket 5: 100%
  Sorting block of length 115 for bucket 4
  (Using difference cover)
  bucket 7: 50%
  bucket 6: 70%
  Sorting block of length 199 for bucket 5
  (Using difference cover)
  Sorting block of length 171 for bucket 3
  (Using difference cover)
  bucket 1: 70%
  bucket 6: 80%
  bucket 1: 80%
  bucket 2: 90%
  bucket 1: 90%
  bucket 2: 100%
  bucket 1: 100%
  Sorting block of length 75 for bucket 1
  (Using difference cover)
  Sorting block of length 202 for bucket 2
  (Using difference cover)
  bucket 7: 60%
  bucket 6: 90%
  bucket 7: 70%
  bucket 6: 100%
  bucket 7: 80%
  Sorting block of length 145 for bucket 6
  (Using difference cover)
  bucket 7: 90%
  bucket 7: 100%
  Sorting block of length 192 for bucket 7
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 172 for bucket 3
  Sorting block time: 00:00:00
Returning block of 76 for bucket 1
  Sorting block time: 00:00:00
Returning block of 116 for bucket 4
  Sorting block time: 00:00:00
Returning block of 200 for bucket 5
  Sorting block time: 00:00:00
Returning block of 146 for bucket 6
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 193 for bucket 7
Returning block of 203 for bucket 2
Exited GFM loop
fchr[A]: 0
fchr[C]: 196
fchr[G]: 568
fchr[T]: 932
fchr[$]: 1105
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4194902 bytes to primary GFM file: TPP_index/TPP_index.1.ht2
Wrote 284 bytes to secondary GFM file: TPP_index/TPP_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 8613 bytes to primary GFM file: TPP_index/TPP_index.5.ht2
Wrote 282 bytes to secondary GFM file: TPP_index/TPP_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 1105
    gbwtLen: 1106
    nodes: 1106
    sz: 277
    gbwtSz: 277
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 70
    offsSz: 280
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 6
    numLines: 6
    gbwtTotLen: 384
    gbwtTotSz: 384
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "yybP-ykoY_index/yybP-ykoY_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  yybP-ykoY.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 208 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 208 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 5; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 122.333 (target: 207)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 9
  Reserving size (208) for bucket 1
Getting block 2 of 9
  Calculating Z arrays for bucket 1
  Reserving size (208) for bucket 2
Getting block 3 of 9
  Reserving size (208) for bucket 3
Getting block 4 of 9
  Reserving size (208) for bucket 4
  Entering block accumulator loop for bucket 1:
Getting block 5 of 9
  Reserving size (208) for bucket 5
Getting block 6 of 9
  Reserving size (208) for bucket 6
  Calculating Z arrays for bucket 5
Getting block 7 of 9
  Entering block accumulator loop for bucket 5:
Getting block 8 of 9
  Reserving size (208) for bucket 8
Getting block 9 of 9
  Reserving size (208) for bucket 7
  Calculating Z arrays for bucket 6
  Calculating Z arrays for bucket 3
  Calculating Z arrays for bucket 4
  bucket 1: 10%
  Calculating Z arrays for bucket 2
  Reserving size (208) for bucket 9
  bucket 5: 10%
  Calculating Z arrays for bucket 9
  Entering block accumulator loop for bucket 2:
  Calculating Z arrays for bucket 7
  Calculating Z arrays for bucket 8
  Entering block accumulator loop for bucket 3:
  Entering block accumulator loop for bucket 9:
  bucket 1: 20%
  Entering block accumulator loop for bucket 7:
  Entering block accumulator loop for bucket 8:
  bucket 3: 10%
  bucket 1: 30%
  Entering block accumulator loop for bucket 6:
  bucket 8: 10%
  bucket 5: 20%
  bucket 6: 10%
  bucket 8: 20%
  bucket 5: 30%
  bucket 1: 40%
  bucket 3: 20%
  bucket 2: 10%
  bucket 5: 40%
  bucket 8: 30%
  bucket 7: 10%
  bucket 8: 40%
  bucket 3: 30%
  bucket 8: 50%
  bucket 7: 20%
  bucket 3: 40%
  bucket 5: 50%
  bucket 2: 20%
  bucket 8: 60%
  bucket 6: 20%
  bucket 5: 60%
  bucket 8: 70%
  Entering block accumulator loop for bucket 4:
  bucket 5: 70%
  bucket 2: 30%
  bucket 5: 80%
  bucket 6: 30%
  bucket 9: 10%
  bucket 3: 50%
  bucket 1: 50%
  bucket 8: 80%
  bucket 9: 20%
  bucket 8: 90%
  bucket 3: 60%
  bucket 4: 10%
  bucket 6: 40%
  bucket 4: 20%
  bucket 9: 30%
  bucket 4: 30%
  bucket 5: 90%
  bucket 2: 40%
  bucket 9: 40%
  bucket 8: 100%
  bucket 7: 30%
  bucket 3: 70%
  bucket 4: 40%
  bucket 3: 80%
  Sorting block of length 198 for bucket 8
  (Using difference cover)
  bucket 5: 100%
  bucket 2: 50%
  bucket 3: 90%
  bucket 1: 60%
  bucket 2: 60%
  Sorting block of length 146 for bucket 5
  (Using difference cover)
  bucket 1: 70%
  bucket 2: 70%
  bucket 1: 80%
  bucket 7: 40%
  bucket 2: 80%
  bucket 9: 50%
  bucket 6: 50%
  bucket 3: 100%
  bucket 9: 60%
  bucket 6: 60%
  Sorting block of length 158 for bucket 3
  (Using difference cover)
  bucket 2: 90%
  bucket 9: 70%
  bucket 2: 100%
  bucket 1: 90%
  Sorting block of length 155 for bucket 2
  (Using difference cover)
  bucket 9: 80%
  bucket 1: 100%
  bucket 9: 90%
  bucket 6: 70%
  Sorting block of length 120 for bucket 1
  (Using difference cover)
  bucket 9: 100%
  bucket 4: 50%
  bucket 7: 50%
  bucket 6: 80%
  Sorting block of length 10 for bucket 9
  bucket 7: 60%
  (Using difference cover)
  bucket 4: 60%
  bucket 6: 90%
  bucket 4: 70%
  bucket 7: 70%
  bucket 4: 80%
  bucket 6: 100%
  bucket 4: 90%
  Sorting block of length 173 for bucket 6
  (Using difference cover)
  bucket 4: 100%
  bucket 7: 80%
  Sorting block of length 76 for bucket 4
  (Using difference cover)
  bucket 7: 90%
  bucket 7: 100%
  Sorting block of length 65 for bucket 7
  (Using difference cover)
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 11 for bucket 9
Returning block of 199 for bucket 8
Returning block of 147 for bucket 5
  Sorting block time: 00:00:00
Returning block of 156 for bucket 2
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 174 for bucket 6
  Sorting block time: 00:00:00
Returning block of 77 for bucket 4
Returning block of 66 for bucket 7
  Sorting block time: 00:00:00
Returning block of 121 for bucket 1
  Sorting block time: 00:00:00
Returning block of 159 for bucket 3
Exited GFM loop
fchr[A]: 0
fchr[C]: 177
fchr[G]: 545
fchr[T]: 912
fchr[$]: 1109
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4194908 bytes to primary GFM file: yybP-ykoY_index/yybP-ykoY_index.1.ht2
Wrote 284 bytes to secondary GFM file: yybP-ykoY_index/yybP-ykoY_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 8613 bytes to primary GFM file: yybP-ykoY_index/yybP-ykoY_index.5.ht2
Wrote 282 bytes to secondary GFM file: yybP-ykoY_index/yybP-ykoY_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 1109
    gbwtLen: 1110
    nodes: 1110
    sz: 278
    gbwtSz: 278
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 70
    offsSz: 280
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 6
    numLines: 6
    gbwtTotLen: 384
    gbwtTotSz: 384
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "ZMP-ZTP_index/ZMP-ZTP_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  ZMP-ZTP.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 405 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 405 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 6; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 307.857 (target: 404)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 7
  Reserving size (405) for bucket 1
  Calculating Z arrays for bucket 1
Getting block 2 of 7
  Reserving size (405) for bucket 2
  Entering block accumulator loop for bucket 1:
Getting block 3 of 7
  Reserving size (405) for bucket 3
Getting block 5 of 7
  Reserving size (405) for bucket 5
Getting block 7 of 7
  Reserving size (405) for bucket 7
  Calculating Z arrays for bucket 2
  Calculating Z arrays for bucket 7
  Calculating Z arrays for bucket 5
  Calculating Z arrays for bucket 3
Getting block 6 of 7
  Entering block accumulator loop for bucket 5:
  Entering block accumulator loop for bucket 2:
  Entering block accumulator loop for bucket 7:
  bucket 1: 10%
  bucket 2: 10%
  bucket 7: 10%
  Entering block accumulator loop for bucket 3:
  bucket 1: 20%
Getting block 4 of 7
  Reserving size (405) for bucket 4
  Reserving size (405) for bucket 6
  bucket 1: 30%
  bucket 2: 20%
  bucket 5: 10%
  Calculating Z arrays for bucket 6
  Calculating Z arrays for bucket 4
  bucket 2: 30%
  bucket 5: 20%
  bucket 3: 10%
  bucket 7: 20%
  bucket 2: 40%
  bucket 1: 40%
  Entering block accumulator loop for bucket 6:
  bucket 7: 30%
  bucket 5: 30%
  bucket 2: 50%
  Entering block accumulator loop for bucket 4:
  bucket 1: 50%
  bucket 7: 40%
  bucket 6: 10%
  bucket 5: 40%
  bucket 2: 60%
  bucket 4: 10%
  bucket 1: 60%
  bucket 6: 20%
  bucket 7: 50%
  bucket 5: 50%
  bucket 1: 70%
  bucket 3: 20%
  bucket 4: 20%
  bucket 6: 30%
  bucket 7: 60%
  bucket 2: 70%
  bucket 4: 30%
  bucket 5: 60%
  bucket 1: 80%
  bucket 2: 80%
  bucket 7: 70%
  bucket 3: 30%
  bucket 1: 90%
  bucket 6: 40%
  bucket 4: 40%
  bucket 5: 70%
  bucket 1: 100%
  bucket 7: 80%
  bucket 4: 50%
  bucket 6: 50%
  Sorting block of length 304 for bucket 1
  (Using difference cover)
  bucket 2: 90%
  bucket 3: 40%
  bucket 5: 80%
  bucket 4: 60%
  bucket 2: 100%
  bucket 5: 90%
  bucket 6: 60%
  bucket 3: 50%
  Sorting block of length 357 for bucket 2
  (Using difference cover)
  bucket 7: 90%
  bucket 3: 60%
  bucket 6: 70%
  bucket 4: 70%
  bucket 3: 70%
  bucket 7: 100%
  bucket 6: 80%
  bucket 4: 80%
  bucket 3: 80%
  bucket 5: 100%
  bucket 6: 90%
  Sorting block of length 398 for bucket 5
  (Using difference cover)
  bucket 4: 90%
  Sorting block of length 277 for bucket 7
  (Using difference cover)
  bucket 6: 100%
  bucket 4: 100%
  Sorting block of length 377 for bucket 4
  (Using difference cover)
  Sorting block of length 201 for bucket 6
  (Using difference cover)
  bucket 3: 90%
  bucket 3: 100%
  Sorting block of length 241 for bucket 3
  (Using difference cover)
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 242 for bucket 3
  Sorting block time: 00:00:00
Returning block of 378 for bucket 4
Returning block of 278 for bucket 7
Returning block of 358 for bucket 2
  Sorting block time: 00:00:00
Returning block of 305 for bucket 1
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 202 for bucket 6
Returning block of 399 for bucket 5
Exited GFM loop
fchr[A]: 0
fchr[C]: 343
fchr[G]: 1054
fchr[T]: 1784
fchr[$]: 2161
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4195335 bytes to primary GFM file: ZMP-ZTP_index/ZMP-ZTP_index.1.ht2
Wrote 548 bytes to secondary GFM file: ZMP-ZTP_index/ZMP-ZTP_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 17197 bytes to primary GFM file: ZMP-ZTP_index/ZMP-ZTP_index.5.ht2
Wrote 548 bytes to secondary GFM file: ZMP-ZTP_index/ZMP-ZTP_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 2161
    gbwtLen: 2162
    nodes: 2162
    sz: 541
    gbwtSz: 541
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 136
    offsSz: 544
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 12
    numLines: 12
    gbwtTotLen: 768
    gbwtTotSz: 768
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:01
Settings:
  Output files: "AdoCbl_riboswitch_index/AdoCbl_riboswitch_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  AdoCbl_riboswitch.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 215 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 215 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 2, merged 8; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 0; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 142.375 (target: 214)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 8
  Reserving size (215) for bucket 1
Getting block 3 of 8
  Reserving size (215) for bucket 3
Getting block 2 of 8
  Reserving size (215) for bucket 2
  Calculating Z arrays for bucket 1
  Calculating Z arrays for bucket 3
  Calculating Z arrays for bucket 2
Getting block 4 of 8
  Reserving size (215) for bucket 4
Getting block 5 of 8
  Entering block accumulator loop for bucket 3:
  Reserving size (215) for bucket 5
Getting block 6 of 8
  Reserving size (215) for bucket 6
  Entering block accumulator loop for bucket 1:
  Calculating Z arrays for bucket 5
Getting block 7 of 8
  Entering block accumulator loop for bucket 2:
  bucket 1: 10%
  Calculating Z arrays for bucket 6
  Reserving size (215) for bucket 7
  Calculating Z arrays for bucket 7
Getting block 8 of 8
  Entering block accumulator loop for bucket 6:
  Reserving size (215) for bucket 8
  Entering block accumulator loop for bucket 5:
  bucket 1: 20%
  bucket 3: 10%
  bucket 6: 10%
  Calculating Z arrays for bucket 4
  bucket 2: 10%
  Calculating Z arrays for bucket 8
  Entering block accumulator loop for bucket 7:
  bucket 3: 20%
  bucket 7: 10%
  bucket 6: 20%
  Entering block accumulator loop for bucket 4:
  bucket 6: 30%
  bucket 3: 30%
  bucket 4: 10%
  bucket 7: 20%
  bucket 3: 40%
  bucket 1: 30%
  bucket 4: 20%
  bucket 1: 40%
  bucket 7: 30%
  bucket 4: 30%
  bucket 7: 40%
  bucket 5: 10%
  bucket 4: 40%
  bucket 6: 40%
  Entering block accumulator loop for bucket 8:
  bucket 3: 50%
  bucket 2: 20%
  bucket 5: 20%
  bucket 3: 60%
  bucket 2: 30%
  bucket 1: 50%
  bucket 7: 50%
  bucket 5: 30%
  bucket 6: 50%
  bucket 2: 40%
  bucket 4: 50%
  bucket 5: 40%
  bucket 6: 60%
  bucket 8: 10%
  bucket 5: 50%
  bucket 3: 70%
  bucket 6: 70%
  bucket 2: 50%
  bucket 3: 80%
  bucket 6: 80%
  bucket 3: 90%
  bucket 4: 60%
  bucket 2: 60%
  bucket 4: 70%
  bucket 5: 60%
  bucket 6: 90%
  bucket 3: 100%
  bucket 4: 80%
  Sorting block of length 125 for bucket 3
  (Using difference cover)
  bucket 6: 100%
  bucket 5: 70%
  bucket 7: 60%
  bucket 2: 70%
  bucket 5: 80%
  bucket 1: 60%
  bucket 4: 90%
  bucket 5: 90%
  bucket 4: 100%
  bucket 5: 100%
  bucket 7: 70%
  Sorting block of length 104 for bucket 4
  (Using difference cover)
  Sorting block of length 170 for bucket 5
  (Using difference cover)
  bucket 1: 70%
  bucket 2: 80%
  Sorting block of length 129 for bucket 6
  (Using difference cover)
  bucket 7: 80%
  bucket 8: 20%
  bucket 7: 90%
  bucket 2: 90%
  bucket 1: 80%
  bucket 7: 100%
  bucket 1: 90%
  bucket 8: 30%
  Sorting block of length 177 for bucket 7
  (Using difference cover)
  bucket 1: 100%
  bucket 8: 40%
  Sorting block of length 195 for bucket 1
  (Using difference cover)
  bucket 8: 50%
  bucket 2: 100%
  Sorting block of length 101 for bucket 2
  (Using difference cover)
  bucket 8: 60%
  bucket 8: 70%
  bucket 8: 80%
  bucket 8: 90%
  bucket 8: 100%
  Sorting block of length 138 for bucket 8
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 126 for bucket 3
  Sorting block time: 00:00:00
Returning block of 105 for bucket 4
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 130 for bucket 6
Returning block of 171 for bucket 5
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 102 for bucket 2
Returning block of 196 for bucket 1
  Sorting block time: 00:00:00
Returning block of 139 for bucket 8
  Sorting block time: 00:00:00
Returning block of 178 for bucket 7
Exited GFM loop
fchr[A]: 0
fchr[C]: 119
fchr[G]: 586
fchr[T]: 989
fchr[$]: 1146
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4194916 bytes to primary GFM file: AdoCbl_riboswitch_index/AdoCbl_riboswitch_index.1.ht2
Wrote 292 bytes to secondary GFM file: AdoCbl_riboswitch_index/AdoCbl_riboswitch_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 8677 bytes to primary GFM file: AdoCbl_riboswitch_index/AdoCbl_riboswitch_index.5.ht2
Wrote 292 bytes to secondary GFM file: AdoCbl_riboswitch_index/AdoCbl_riboswitch_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 1146
    gbwtLen: 1147
    nodes: 1147
    sz: 287
    gbwtSz: 287
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 72
    offsSz: 288
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 6
    numLines: 6
    gbwtTotLen: 384
    gbwtTotSz: 384
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "Cobalamin_index/Cobalamin_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  Cobalamin.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 1944 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 1944 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 7; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 1; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 1726.67 (target: 1943)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 6
  Reserving size (1944) for bucket 1
Getting block 2 of 6
  Reserving size (1944) for bucket 2
  Calculating Z arrays for bucket 1
  Calculating Z arrays for bucket 2
Getting block 3 of 6
  Entering block accumulator loop for bucket 1:
  Reserving size (1944) for bucket 3
Getting block 4 of 6
  Reserving size (1944) for bucket 4
  Entering block accumulator loop for bucket 2:
  Calculating Z arrays for bucket 3
  Calculating Z arrays for bucket 4
Getting block 6 of 6
  Reserving size (1944) for bucket 6
  bucket 1: 10%
  bucket 2: 10%
  Entering block accumulator loop for bucket 3:
  Calculating Z arrays for bucket 6
  Entering block accumulator loop for bucket 4:
Getting block 5 of 6
  Reserving size (1944) for bucket 5
  bucket 2: 20%
  Entering block accumulator loop for bucket 6:
  bucket 1: 20%
  bucket 3: 10%
  bucket 4: 10%
  Calculating Z arrays for bucket 5
  bucket 1: 30%
  bucket 2: 30%
  bucket 6: 10%
  bucket 1: 40%
  Entering block accumulator loop for bucket 5:
  bucket 4: 20%
  bucket 3: 20%
  bucket 2: 40%
  bucket 1: 50%
  bucket 6: 20%
  bucket 1: 60%
  bucket 4: 30%
  bucket 2: 50%
  bucket 1: 70%
  bucket 6: 30%
  bucket 5: 10%
  bucket 3: 30%
  bucket 1: 80%
  bucket 4: 40%
  bucket 6: 40%
  bucket 2: 60%
  bucket 1: 90%
  bucket 5: 20%
  bucket 1: 100%
  bucket 6: 50%
  Sorting block of length 1406 for bucket 1
  (Using difference cover)
  bucket 4: 50%
  bucket 3: 40%
  bucket 2: 70%
  bucket 5: 30%
  bucket 6: 60%
  bucket 4: 60%
  bucket 2: 80%
  bucket 6: 70%
  bucket 5: 40%
  bucket 3: 50%
  bucket 2: 90%
  bucket 6: 80%
  bucket 4: 70%
  bucket 5: 50%
  bucket 2: 100%
  Sorting block of length 1675 for bucket 2
  (Using difference cover)
  bucket 6: 90%
  bucket 4: 80%
  bucket 5: 60%
  bucket 3: 60%
  bucket 6: 100%
  Sorting block of length 1668 for bucket 6
  (Using difference cover)
  bucket 4: 90%
  bucket 5: 70%
  bucket 3: 70%
  bucket 4: 100%
  Sorting block of length 1774 for bucket 4
  (Using difference cover)
  bucket 5: 80%
  bucket 3: 80%
  bucket 5: 90%
  bucket 3: 90%
  bucket 5: 100%
  Sorting block of length 1897 for bucket 5
  (Using difference cover)
  bucket 3: 100%
  Sorting block of length 1940 for bucket 3
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 1407 for bucket 1
  Sorting block time: 00:00:00
Returning block of 1676 for bucket 2
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 1941 for bucket 3
  Sorting block time: 00:00:00
Returning block of 1775 for bucket 4
Returning block of 1669 for bucket 6
Returning block of 1898 for bucket 5
Exited GFM loop
fchr[A]: 0
fchr[C]: 1394
fchr[G]: 5260
fchr[T]: 8888
fchr[$]: 10365
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4198420 bytes to primary GFM file: Cobalamin_index/Cobalamin_index.1.ht2
Wrote 2596 bytes to secondary GFM file: Cobalamin_index/Cobalamin_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 77733 bytes to primary GFM file: Cobalamin_index/Cobalamin_index.5.ht2
Wrote 2604 bytes to secondary GFM file: Cobalamin_index/Cobalamin_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 10365
    gbwtLen: 10366
    nodes: 10366
    sz: 2592
    gbwtSz: 2592
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 648
    offsSz: 2592
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 54
    numLines: 54
    gbwtTotLen: 3456
    gbwtTotSz: 3456
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "FMN_index/FMN_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  FMN.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 212 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 212 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 8; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 0; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 1; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 0; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 1; iterating...
Avg bucket size: 140.375 (target: 211)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 8
  Reserving size (212) for bucket 1
  Calculating Z arrays for bucket 1
Getting block 2 of 8
  Reserving size (212) for bucket 2
Getting block 3 of 8
  Calculating Z arrays for bucket 2
Getting block 4 of 8
Getting block 5 of 8
  Entering block accumulator loop for bucket 2:
  Reserving size (212) for bucket 3
Getting block 7 of 8
  Calculating Z arrays for bucket 3
Getting block 8 of 8
  Entering block accumulator loop for bucket 3:
  Reserving size (212) for bucket 7
  Reserving size (212) for bucket 4
  Reserving size (212) for bucket 8
Getting block 6 of 8
  Calculating Z arrays for bucket 7
  Calculating Z arrays for bucket 4
  Reserving size (212) for bucket 5
  Reserving size (212) for bucket 6
  Calculating Z arrays for bucket 8
  Entering block accumulator loop for bucket 7:
  bucket 2: 10%
  Calculating Z arrays for bucket 6
  Calculating Z arrays for bucket 5
  bucket 2: 20%
  Entering block accumulator loop for bucket 4:
  bucket 2: 30%
  bucket 3: 10%
  Entering block accumulator loop for bucket 1:
  Entering block accumulator loop for bucket 8:
  bucket 2: 40%
  bucket 4: 10%
  Entering block accumulator loop for bucket 6:
  bucket 1: 10%
  bucket 3: 20%
  bucket 7: 10%
  bucket 2: 50%
  bucket 1: 20%
  bucket 4: 20%
  Entering block accumulator loop for bucket 5:
  bucket 8: 10%
  bucket 1: 30%
  bucket 7: 20%
  bucket 2: 60%
  bucket 6: 10%
  bucket 7: 30%
  bucket 4: 30%
  bucket 3: 30%
  bucket 7: 40%
  bucket 4: 40%
  bucket 1: 40%
  bucket 6: 20%
  bucket 1: 50%
  bucket 2: 70%
  bucket 5: 10%
  bucket 4: 50%
  bucket 7: 50%
  bucket 6: 30%
  bucket 8: 20%
  bucket 6: 40%
  bucket 4: 60%
  bucket 2: 80%
  bucket 8: 30%
  bucket 1: 60%
  bucket 2: 90%
  bucket 7: 60%
  bucket 1: 70%
  bucket 5: 20%
  bucket 7: 70%
  bucket 2: 100%
  bucket 3: 40%
  Sorting block of length 208 for bucket 2
  (Using difference cover)
  bucket 4: 70%
  bucket 7: 80%
  bucket 5: 30%
  bucket 4: 80%
  bucket 8: 40%
  bucket 1: 80%
  bucket 5: 40%
  bucket 4: 90%
  bucket 8: 50%
  bucket 5: 50%
  bucket 8: 60%
  bucket 4: 100%
  bucket 8: 70%
  bucket 1: 90%
  bucket 3: 50%
  bucket 1: 100%
  bucket 7: 90%
  Sorting block of length 140 for bucket 4
  (Using difference cover)
  bucket 7: 100%
  bucket 6: 50%
  bucket 3: 60%
  bucket 8: 80%
  bucket 5: 60%
  Sorting block of length 147 for bucket 1
  (Using difference cover)
  bucket 6: 60%
  bucket 8: 90%
  bucket 3: 70%
  bucket 6: 70%
  bucket 5: 70%
  Sorting block of length 182 for bucket 7
  (Using difference cover)
  bucket 5: 80%
  bucket 8: 100%
  bucket 3: 80%
  bucket 6: 80%
  Sorting block of length 60 for bucket 8
  (Using difference cover)
  bucket 5: 90%
  bucket 6: 90%
  bucket 3: 90%
  bucket 6: 100%
  bucket 5: 100%
  Sorting block of length 29 for bucket 6
  (Using difference cover)
  Sorting block of length 167 for bucket 5
  (Using difference cover)
  bucket 3: 100%
  Sorting block of length 190 for bucket 3
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 209 for bucket 2
  Sorting block time: 00:00:00
Returning block of 141 for bucket 4
  Sorting block time: 00:00:00
Returning block of 148 for bucket 1
  Sorting block time: 00:00:00
Returning block of 183 for bucket 7
  Sorting block time: 00:00:00
Returning block of 61 for bucket 8
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 30 for bucket 6
Returning block of 168 for bucket 5
  Sorting block time: 00:00:00
Returning block of 191 for bucket 3
Exited GFM loop
fchr[A]: 0
fchr[C]: 173
fchr[G]: 556
fchr[T]: 961
fchr[$]: 1130
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4194902 bytes to primary GFM file: FMN_index/FMN_index.1.ht2
Wrote 288 bytes to secondary GFM file: FMN_index/FMN_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 8677 bytes to primary GFM file: FMN_index/FMN_index.5.ht2
Wrote 288 bytes to secondary GFM file: FMN_index/FMN_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 1130
    gbwtLen: 1131
    nodes: 1131
    sz: 283
    gbwtSz: 283
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 71
    offsSz: 284
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 6
    numLines: 6
    gbwtTotLen: 384
    gbwtTotSz: 384
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "Glycine_index/Glycine_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  Glycine.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 411 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 411 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 7; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 311.714 (target: 410)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 7
  Reserving size (411) for bucket 1
Getting block 2 of 7
  Reserving size (411) for bucket 2
  Calculating Z arrays for bucket 1
  Calculating Z arrays for bucket 2
  Entering block accumulator loop for bucket 1:
Getting block 3 of 7
Getting block 4 of 7
Getting block 5 of 7
  Reserving size (411) for bucket 5
  Reserving size (411) for bucket 3
  Calculating Z arrays for bucket 5
Getting block 7 of 7
  Entering block accumulator loop for bucket 5:
  bucket 1: 10%
  Reserving size (411) for bucket 7
Getting block 6 of 7
  Reserving size (411) for bucket 6
  Reserving size (411) for bucket 4
  Entering block accumulator loop for bucket 2:
  Calculating Z arrays for bucket 6
  bucket 5: 10%
  Calculating Z arrays for bucket 3
  bucket 5: 20%
  bucket 2: 10%
  bucket 1: 20%
  bucket 5: 30%
  Calculating Z arrays for bucket 4
  bucket 2: 20%
  bucket 1: 30%
  bucket 5: 40%
  Entering block accumulator loop for bucket 3:
  bucket 5: 50%
  bucket 2: 30%
  Calculating Z arrays for bucket 7
  bucket 5: 60%
  bucket 2: 40%
  bucket 1: 40%
  bucket 5: 70%
  bucket 1: 50%
  bucket 5: 80%
  bucket 2: 50%
  bucket 3: 10%
  bucket 5: 90%
  bucket 1: 60%
  bucket 2: 60%
  bucket 1: 70%
  bucket 3: 20%
  bucket 5: 100%
  bucket 2: 70%
  Sorting block of length 150 for bucket 5
  bucket 3: 30%
  bucket 1: 80%
  (Using difference cover)
  bucket 2: 80%
  bucket 1: 90%
  bucket 3: 40%
  bucket 1: 100%
  Sorting block of length 308 for bucket 1
  (Using difference cover)
  bucket 3: 50%
  bucket 2: 90%
  bucket 3: 60%
  bucket 2: 100%
  Sorting block of length 395 for bucket 2
  (Using difference cover)
  bucket 3: 70%
  bucket 3: 80%
  bucket 3: 90%
  bucket 3: 100%
  Sorting block of length 405 for bucket 3
  (Using difference cover)
  Entering block accumulator loop for bucket 6:
  Entering block accumulator loop for bucket 7:
  bucket 6: 10%
  bucket 7: 10%
  bucket 6: 20%
  bucket 7: 20%
  bucket 6: 30%
  bucket 7: 30%
  bucket 6: 40%
  bucket 7: 40%
  bucket 6: 50%
  bucket 7: 50%
  Entering block accumulator loop for bucket 4:
  bucket 6: 60%
  bucket 7: 60%
  bucket 4: 10%
  bucket 7: 70%
  bucket 6: 70%
  bucket 7: 80%
  bucket 4: 20%
  bucket 6: 80%
  bucket 7: 90%
  bucket 4: 30%
  bucket 6: 90%
  bucket 7: 100%
  bucket 4: 40%
  bucket 6: 100%
  Sorting block of length 119 for bucket 7
  (Using difference cover)
  bucket 4: 50%
  Sorting block of length 397 for bucket 6
  bucket 4: 60%
  (Using difference cover)
  bucket 4: 70%
  bucket 4: 80%
  bucket 4: 90%
  bucket 4: 100%
  Sorting block of length 408 for bucket 4
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 309 for bucket 1
  Sorting block time: 00:00:00
Returning block of 406 for bucket 3
  Sorting block time: 00:00:00
Returning block of 151 for bucket 5
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 120 for bucket 7
Returning block of 396 for bucket 2
  Sorting block time: 00:00:00
Returning block of 409 for bucket 4
  Sorting block time: 00:00:00
Returning block of 398 for bucket 6
Exited GFM loop
fchr[A]: 0
fchr[C]: 354
fchr[G]: 1097
fchr[T]: 1861
fchr[$]: 2188
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4195343 bytes to primary GFM file: Glycine_index/Glycine_index.1.ht2
Wrote 552 bytes to secondary GFM file: Glycine_index/Glycine_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 17197 bytes to primary GFM file: Glycine_index/Glycine_index.5.ht2
Wrote 552 bytes to secondary GFM file: Glycine_index/Glycine_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 2188
    gbwtLen: 2189
    nodes: 2189
    sz: 547
    gbwtSz: 548
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 137
    offsSz: 548
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 12
    numLines: 12
    gbwtTotLen: 768
    gbwtTotSz: 768
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "SAM_index/SAM_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  SAM.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 215 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 215 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 11 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 6; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 0; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 142.5 (target: 214)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 8
  Reserving size (215) for bucket 1
Getting block 2 of 8
  Reserving size (215) for bucket 2
Getting block 3 of 8
  Reserving size (215) for bucket 3
  Calculating Z arrays for bucket 2
Getting block 4 of 8
  Calculating Z arrays for bucket 3
Getting block 5 of 8
  Reserving size (215) for bucket 4
  Reserving size (215) for bucket 5
  Entering block accumulator loop for bucket 3:
  Entering block accumulator loop for bucket 2:
Getting block 6 of 8
  Calculating Z arrays for bucket 1
  bucket 2: 10%
  Calculating Z arrays for bucket 4
  bucket 2: 20%
  bucket 3: 10%
  bucket 2: 30%
Getting block 7 of 8
  Reserving size (215) for bucket 7
  Entering block accumulator loop for bucket 4:
  Reserving size (215) for bucket 6
  Entering block accumulator loop for bucket 1:
  bucket 4: 10%
  bucket 1: 10%
  Calculating Z arrays for bucket 6
  Calculating Z arrays for bucket 7
  bucket 2: 40%
  Calculating Z arrays for bucket 5
  bucket 2: 50%
  bucket 1: 20%
  bucket 3: 20%
  bucket 2: 60%
  bucket 1: 30%
  bucket 4: 20%
  Entering block accumulator loop for bucket 6:
  bucket 4: 30%
  bucket 3: 30%
  bucket 2: 70%
  bucket 6: 10%
Getting block 8 of 8
  bucket 2: 80%
  bucket 6: 20%
  bucket 4: 40%
  Reserving size (215) for bucket 8
  bucket 6: 30%
  bucket 3: 40%
  bucket 6: 40%
  bucket 2: 90%
  bucket 1: 40%
  bucket 3: 50%
  bucket 2: 100%
  Entering block accumulator loop for bucket 5:
  Sorting block of length 170 for bucket 2
  bucket 1: 50%
  (Using difference cover)
  bucket 3: 60%
  bucket 1: 60%
  bucket 4: 50%
  Calculating Z arrays for bucket 8
  bucket 6: 50%
  Entering block accumulator loop for bucket 7:
  bucket 5: 10%
  Entering block accumulator loop for bucket 8:
  bucket 5: 20%
  bucket 3: 70%
  bucket 1: 70%
  bucket 5: 30%
  bucket 6: 60%
  bucket 5: 40%
  bucket 3: 80%
  bucket 5: 50%
  bucket 3: 90%
  bucket 6: 70%
  bucket 8: 10%
  bucket 1: 80%
  bucket 8: 20%
  bucket 4: 60%
  bucket 8: 30%
  bucket 6: 80%
  bucket 8: 40%
  bucket 1: 90%
  bucket 4: 70%
  bucket 8: 50%
  bucket 4: 80%
  bucket 1: 100%
  bucket 6: 90%
  bucket 4: 90%
  bucket 6: 100%
  bucket 5: 60%
  Sorting block of length 130 for bucket 1
  (Using difference cover)
  bucket 7: 10%
  bucket 5: 70%
  bucket 4: 100%
  bucket 5: 80%
  bucket 8: 60%
  bucket 3: 100%
  Sorting block of length 165 for bucket 4
  (Using difference cover)
  bucket 7: 20%
  bucket 8: 70%
  bucket 5: 90%
  bucket 8: 80%
  bucket 5: 100%
  bucket 7: 30%
  Sorting block of length 165 for bucket 6
  (Using difference cover)
  bucket 7: 40%
  Sorting block of length 171 for bucket 3
  (Using difference cover)
  Sorting block of length 78 for bucket 5
  (Using difference cover)
  bucket 8: 90%
  bucket 7: 50%
  bucket 8: 100%
  bucket 7: 60%
  Sorting block of length 89 for bucket 8
  (Using difference cover)
  bucket 7: 70%
  bucket 7: 80%
  bucket 7: 90%
  bucket 7: 100%
  Sorting block of length 172 for bucket 7
  (Using difference cover)
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 172 for bucket 3
  Sorting block time: 00:00:00
Returning block of 171 for bucket 2
Returning block of 79 for bucket 5
Returning block of 90 for bucket 8
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 166 for bucket 6
Returning block of 166 for bucket 4
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 131 for bucket 1
Returning block of 173 for bucket 7
Exited GFM loop
fchr[A]: 0
fchr[C]: 191
fchr[G]: 632
fchr[T]: 983
fchr[$]: 1147
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4194902 bytes to primary GFM file: SAM_index/SAM_index.1.ht2
Wrote 292 bytes to secondary GFM file: SAM_index/SAM_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 8677 bytes to primary GFM file: SAM_index/SAM_index.5.ht2
Wrote 292 bytes to secondary GFM file: SAM_index/SAM_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 1147
    gbwtLen: 1148
    nodes: 1148
    sz: 287
    gbwtSz: 288
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 72
    offsSz: 288
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 6
    numLines: 6
    gbwtTotLen: 384
    gbwtTotSz: 384
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "SAM-IV_index/SAM-IV_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  SAM-IV.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 210 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 210 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 158.571 (target: 209)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 7
  Reserving size (210) for bucket 1
Getting block 2 of 7
  Reserving size (210) for bucket 2
Getting block 3 of 7
  Reserving size (210) for bucket 3
  Calculating Z arrays for bucket 1
  Calculating Z arrays for bucket 3
  Calculating Z arrays for bucket 2
  Entering block accumulator loop for bucket 1:
Getting block 4 of 7
  Reserving size (210) for bucket 4
  bucket 1: 10%
Getting block 5 of 7
  Reserving size (210) for bucket 5
  Calculating Z arrays for bucket 4
  Entering block accumulator loop for bucket 2:
  Calculating Z arrays for bucket 5
  bucket 1: 20%
  bucket 2: 10%
Getting block 7 of 7
  Entering block accumulator loop for bucket 3:
  Reserving size (210) for bucket 7
  bucket 2: 20%
  Calculating Z arrays for bucket 7
  Entering block accumulator loop for bucket 4:
  bucket 2: 30%
Getting block 6 of 7
  bucket 3: 10%
  Reserving size (210) for bucket 6
  bucket 1: 30%
  bucket 4: 10%
  bucket 1: 40%
  Entering block accumulator loop for bucket 7:
  bucket 4: 20%
  bucket 2: 40%
  Entering block accumulator loop for bucket 5:
  bucket 7: 10%
  bucket 4: 30%
  bucket 1: 50%
  bucket 3: 20%
  bucket 1: 60%
  bucket 7: 20%
  bucket 2: 50%
  bucket 3: 30%
  Calculating Z arrays for bucket 6
  bucket 7: 30%
  bucket 4: 40%
  bucket 2: 60%
  bucket 7: 40%
  bucket 5: 10%
  Entering block accumulator loop for bucket 6:
  bucket 5: 20%
  bucket 6: 10%
  bucket 2: 70%
  bucket 5: 30%
  bucket 7: 50%
  bucket 6: 20%
  bucket 2: 80%
  bucket 4: 50%
  bucket 5: 40%
  bucket 6: 30%
  bucket 7: 60%
  bucket 6: 40%
  bucket 4: 60%
  bucket 7: 70%
  bucket 5: 50%
  bucket 2: 90%
  bucket 1: 70%
  bucket 5: 60%
  bucket 3: 40%
  bucket 1: 80%
  bucket 5: 70%
  bucket 1: 90%
  bucket 4: 70%
  bucket 3: 50%
  bucket 2: 100%
  bucket 7: 80%
  Sorting block of length 121 for bucket 2
  (Using difference cover)
  bucket 1: 100%
  bucket 7: 90%
  bucket 3: 60%
  bucket 5: 80%
  Sorting block of length 179 for bucket 1
  (Using difference cover)
  bucket 7: 100%
  bucket 5: 90%
  bucket 3: 70%
  bucket 5: 100%
  Sorting block of length 149 for bucket 7
  (Using difference cover)
  Sorting block of length 142 for bucket 5
  (Using difference cover)
  bucket 3: 80%
  bucket 4: 80%
  bucket 3: 90%
  bucket 4: 90%
  bucket 3: 100%
  bucket 6: 50%
  bucket 4: 100%
  Sorting block of length 169 for bucket 3
  (Using difference cover)
  bucket 6: 60%
  Sorting block of length 207 for bucket 4
  (Using difference cover)
  bucket 6: 70%
  bucket 6: 80%
  bucket 6: 90%
  bucket 6: 100%
  Sorting block of length 143 for bucket 6
  (Using difference cover)
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 170 for bucket 3
Returning block of 143 for bucket 5
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 208 for bucket 4
Returning block of 122 for bucket 2
Returning block of 180 for bucket 1
  Sorting block time: 00:00:00
Returning block of 144 for bucket 6
  Sorting block time: 00:00:00
Returning block of 150 for bucket 7
Exited GFM loop
fchr[A]: 0
fchr[C]: 135
fchr[G]: 556
fchr[T]: 947
fchr[$]: 1116
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4194905 bytes to primary GFM file: SAM-IV_index/SAM-IV_index.1.ht2
Wrote 284 bytes to secondary GFM file: SAM-IV_index/SAM-IV_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 8613 bytes to primary GFM file: SAM-IV_index/SAM-IV_index.5.ht2
Wrote 284 bytes to secondary GFM file: SAM-IV_index/SAM-IV_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 1116
    gbwtLen: 1117
    nodes: 1117
    sz: 279
    gbwtSz: 280
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 70
    offsSz: 280
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 6
    numLines: 6
    gbwtTotLen: 384
    gbwtTotSz: 384
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "TPP_index/TPP_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  TPP.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 416 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 416 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 315.714 (target: 415)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 7
  Reserving size (416) for bucket 1
Getting block 2 of 7
  Reserving size (416) for bucket 2
  Calculating Z arrays for bucket 1
Getting block 3 of 7
  Reserving size (416) for bucket 3
  Calculating Z arrays for bucket 2
  Calculating Z arrays for bucket 3
Getting block 4 of 7
  Entering block accumulator loop for bucket 2:
  Reserving size (416) for bucket 4
  Entering block accumulator loop for bucket 3:
  Calculating Z arrays for bucket 4
Getting block 7 of 7
  bucket 3: 10%
Getting block 6 of 7
  Reserving size (416) for bucket 6
  bucket 2: 10%
  Entering block accumulator loop for bucket 1:
  bucket 3: 20%
  Entering block accumulator loop for bucket 4:
  bucket 1: 10%
  Calculating Z arrays for bucket 6
  bucket 4: 10%
Getting block 5 of 7
  Reserving size (416) for bucket 5
  bucket 2: 20%
  Reserving size (416) for bucket 7
  Entering block accumulator loop for bucket 6:
  bucket 2: 30%
  Calculating Z arrays for bucket 5
  bucket 2: 40%
  bucket 4: 20%
  bucket 1: 20%
  bucket 3: 30%
  bucket 6: 10%
  bucket 4: 30%
  bucket 3: 40%
  bucket 2: 50%
  bucket 3: 50%
  Calculating Z arrays for bucket 7
  bucket 3: 60%
  Entering block accumulator loop for bucket 5:
  bucket 1: 30%
  bucket 3: 70%
  bucket 4: 40%
  bucket 3: 80%
  Entering block accumulator loop for bucket 7:
  bucket 4: 50%
  bucket 1: 40%
  bucket 7: 10%
  bucket 2: 60%
  bucket 6: 20%
  bucket 3: 90%
  bucket 4: 60%
  bucket 3: 100%
  bucket 2: 70%
  Sorting block of length 321 for bucket 3
  (Using difference cover)
  bucket 7: 20%
  bucket 1: 50%
  bucket 6: 30%
  bucket 1: 60%
  bucket 5: 10%
  bucket 7: 30%
  bucket 6: 40%
  bucket 4: 70%
  bucket 1: 70%
  bucket 2: 80%
  bucket 7: 40%
  bucket 1: 80%
  bucket 5: 20%
  bucket 6: 50%
  bucket 7: 50%
  bucket 1: 90%
  bucket 2: 90%
  bucket 7: 60%
  bucket 5: 30%
  bucket 1: 100%
  bucket 4: 80%
  bucket 7: 70%
  Sorting block of length 216 for bucket 1
  (Using difference cover)
  bucket 5: 40%
  bucket 4: 90%
  bucket 6: 60%
  bucket 2: 100%
  bucket 7: 80%
  bucket 5: 50%
  bucket 6: 70%
  bucket 7: 90%
  bucket 4: 100%
  bucket 6: 80%
  bucket 7: 100%
  Sorting block of length 382 for bucket 7
  (Using difference cover)
  bucket 6: 90%
  bucket 5: 60%
  Sorting block of length 415 for bucket 2
  (Using difference cover)
  bucket 6: 100%
  bucket 5: 70%
  Sorting block of length 406 for bucket 4
  (Using difference cover)
  Sorting block of length 124 for bucket 6
  (Using difference cover)
  bucket 5: 80%
  bucket 5: 90%
  bucket 5: 100%
  Sorting block of length 346 for bucket 5
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 217 for bucket 1
  Sorting block time: 00:00:00
Returning block of 322 for bucket 3
  Sorting block time: 00:00:00
Returning block of 383 for bucket 7
  Sorting block time: 00:00:00
Returning block of 347 for bucket 5
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 125 for bucket 6
  Sorting block time: 00:00:00
Returning block of 416 for bucket 2
Returning block of 407 for bucket 4
Exited GFM loop
fchr[A]: 0
fchr[C]: 321
fchr[G]: 1138
fchr[T]: 1926
fchr[$]: 2216
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4195335 bytes to primary GFM file: TPP_index/TPP_index.1.ht2
Wrote 560 bytes to secondary GFM file: TPP_index/TPP_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 17197 bytes to primary GFM file: TPP_index/TPP_index.5.ht2
Wrote 560 bytes to secondary GFM file: TPP_index/TPP_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 2216
    gbwtLen: 2217
    nodes: 2217
    sz: 554
    gbwtSz: 555
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 139
    offsSz: 556
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 12
    numLines: 12
    gbwtTotLen: 768
    gbwtTotSz: 768
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:01
Settings:
  Output files: "ydaO-yuaA_index/ydaO-yuaA_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  ydaO-yuaA.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 1312 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 1312 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 6; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 873.75 (target: 1311)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 8
  Reserving size (1312) for bucket 1
Getting block 2 of 8
  Calculating Z arrays for bucket 1
Getting block 3 of 8
  Reserving size (1312) for bucket 3
  Entering block accumulator loop for bucket 1:
Getting block 4 of 8
Getting block 6 of 8
  Reserving size (1312) for bucket 6
  Reserving size (1312) for bucket 4
  bucket 1: 10%
  Calculating Z arrays for bucket 4
  Reserving size (1312) for bucket 2
  Calculating Z arrays for bucket 6
  Calculating Z arrays for bucket 2
Getting block 7 of 8
  Reserving size (1312) for bucket 7
  Entering block accumulator loop for bucket 2:
  Entering block accumulator loop for bucket 4:
  bucket 1: 20%
  Entering block accumulator loop for bucket 6:
  Calculating Z arrays for bucket 7
  bucket 1: 30%
Getting block 5 of 8
  Reserving size (1312) for bucket 5
  Entering block accumulator loop for bucket 7:
  Calculating Z arrays for bucket 3
Getting block 8 of 8
  Reserving size (1312) for bucket 8
  bucket 7: 10%
  Calculating Z arrays for bucket 8
  bucket 4: 10%
  Entering block accumulator loop for bucket 3:
  bucket 6: 10%
  bucket 1: 40%
  Calculating Z arrays for bucket 5
  bucket 7: 20%
  bucket 1: 50%
  bucket 6: 20%
  bucket 4: 20%
  bucket 2: 10%
  Entering block accumulator loop for bucket 8:
  bucket 1: 60%
  bucket 7: 30%
  bucket 3: 10%
  Entering block accumulator loop for bucket 5:
  bucket 4: 30%
  bucket 2: 20%
  bucket 8: 10%
  bucket 1: 70%
  bucket 7: 40%
  bucket 6: 30%
  bucket 3: 20%
  bucket 1: 80%
  bucket 8: 20%
  bucket 2: 30%
  bucket 7: 50%
  bucket 1: 90%
  bucket 4: 40%
  bucket 5: 10%
  bucket 3: 30%
  bucket 1: 100%
  bucket 8: 30%
  bucket 6: 40%
  bucket 2: 40%
  Sorting block of length 221 for bucket 1
  (Using difference cover)
  bucket 7: 60%
  bucket 5: 20%
  bucket 3: 40%
  bucket 8: 40%
  bucket 6: 50%
  bucket 4: 50%
  bucket 2: 50%
  bucket 5: 30%
  bucket 3: 50%
  bucket 7: 70%
  bucket 8: 50%
  bucket 2: 60%
  bucket 4: 60%
  bucket 6: 60%
  bucket 5: 40%
  bucket 8: 60%
  bucket 3: 60%
  bucket 7: 80%
  bucket 2: 70%
  bucket 4: 70%
  bucket 8: 70%
  bucket 7: 90%
  bucket 5: 50%
  bucket 3: 70%
  bucket 6: 70%
  bucket 2: 80%
  bucket 8: 80%
  bucket 4: 80%
  bucket 7: 100%
  bucket 3: 80%
  bucket 5: 60%
  Sorting block of length 1175 for bucket 7
  (Using difference cover)
  bucket 2: 90%
  bucket 8: 90%
  bucket 6: 80%
  bucket 3: 90%
  bucket 4: 90%
  bucket 5: 70%
  bucket 2: 100%
  bucket 8: 100%
  Sorting block of length 1053 for bucket 8
  (Using difference cover)
  Sorting block of length 1158 for bucket 2
  (Using difference cover)
  bucket 4: 100%
  bucket 6: 90%
  bucket 5: 80%
  bucket 3: 100%
  Sorting block of length 770 for bucket 3
  (Using difference cover)
  Sorting block of length 627 for bucket 4
  (Using difference cover)
  bucket 5: 90%
  bucket 6: 100%
  Sorting block of length 1007 for bucket 6
  (Using difference cover)
  bucket 5: 100%
  Sorting block of length 979 for bucket 5
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 771 for bucket 3
  Sorting block time: 00:00:00
Returning block of 222 for bucket 1
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 1054 for bucket 8
Returning block of 628 for bucket 4
  Sorting block time: 00:00:00
Returning block of 1176 for bucket 7
  Sorting block time: 00:00:00
Returning block of 1159 for bucket 2
  Sorting block time: 00:00:00
Returning block of 1008 for bucket 6
  Sorting block time: 00:00:00
Returning block of 980 for bucket 5
Exited GFM loop
fchr[A]: 0
fchr[C]: 1213
fchr[G]: 3821
fchr[T]: 6100
fchr[$]: 6997
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4197167 bytes to primary GFM file: ydaO-yuaA_index/ydaO-yuaA_index.1.ht2
Wrote 1756 bytes to secondary GFM file: ydaO-yuaA_index/ydaO-yuaA_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 51917 bytes to primary GFM file: ydaO-yuaA_index/ydaO-yuaA_index.5.ht2
Wrote 1758 bytes to secondary GFM file: ydaO-yuaA_index/ydaO-yuaA_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 6997
    gbwtLen: 6998
    nodes: 6998
    sz: 1750
    gbwtSz: 1750
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 438
    offsSz: 1752
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 37
    numLines: 37
    gbwtTotLen: 2368
    gbwtTotSz: 2368
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "ZMP-ZTP_index/ZMP-ZTP_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  ZMP-ZTP.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 204 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 204 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 2, merged 6; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 1; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 135.25 (target: 203)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 8
  Reserving size (204) for bucket 1
Getting block 2 of 8
  Reserving size (204) for bucket 2
Getting block 3 of 8
Getting block 4 of 8
  Reserving size (204) for bucket 4
  Reserving size (204) for bucket 3
  Calculating Z arrays for bucket 4
  Calculating Z arrays for bucket 3
  Calculating Z arrays for bucket 2
Getting block 6 of 8
  Entering block accumulator loop for bucket 2:
  Entering block accumulator loop for bucket 3:
  bucket 2: 10%
  Entering block accumulator loop for bucket 4:
  bucket 3: 10%
Getting block 7 of 8
  Calculating Z arrays for bucket 1
  Reserving size (204) for bucket 6
  bucket 2: 20%
  Entering block accumulator loop for bucket 1:
  bucket 2: 30%
Getting block 5 of 8
Getting block 8 of 8
  Reserving size (204) for bucket 7
  bucket 1: 10%
  Reserving size (204) for bucket 5
  bucket 1: 20%
  Calculating Z arrays for bucket 5
  Reserving size (204) for bucket 8
  Calculating Z arrays for bucket 6
  Calculating Z arrays for bucket 8
  Calculating Z arrays for bucket 7
  Entering block accumulator loop for bucket 5:
  bucket 2: 40%
  bucket 5: 10%
  bucket 3: 20%
  bucket 5: 20%
  Entering block accumulator loop for bucket 6:
  bucket 2: 50%
  bucket 1: 30%
  Entering block accumulator loop for bucket 8:
  bucket 6: 10%
  bucket 1: 40%
  bucket 5: 30%
  bucket 2: 60%
  bucket 5: 40%
  bucket 3: 30%
  bucket 2: 70%
  Entering block accumulator loop for bucket 7:
  bucket 1: 50%
  bucket 5: 50%
  bucket 1: 60%
  bucket 4: 10%
  bucket 8: 10%
  bucket 6: 20%
  bucket 1: 70%
  bucket 2: 80%
  bucket 6: 30%
  bucket 1: 80%
  bucket 5: 60%
  bucket 3: 40%
  bucket 1: 90%
  bucket 8: 20%
  bucket 1: 100%
  bucket 5: 70%
  bucket 6: 40%
  bucket 4: 20%
  bucket 5: 80%
  bucket 3: 50%
  bucket 5: 90%
  bucket 8: 30%
  bucket 5: 100%
  bucket 7: 10%
  bucket 2: 90%
  Sorting block of length 143 for bucket 1
  (Using difference cover)
  bucket 2: 100%
  bucket 7: 20%
  bucket 8: 40%
  bucket 6: 50%
  bucket 7: 30%
  Sorting block of length 77 for bucket 2
  (Using difference cover)
  bucket 6: 60%
  bucket 4: 30%
  bucket 8: 50%
  bucket 4: 40%
  bucket 6: 70%
  bucket 8: 60%
  bucket 3: 60%
  bucket 6: 80%
  bucket 8: 70%
  bucket 3: 70%
  bucket 4: 50%
  bucket 3: 80%
  bucket 6: 90%
  bucket 7: 40%
  bucket 6: 100%
  bucket 4: 60%
  bucket 8: 80%
  bucket 7: 50%
  bucket 8: 90%
  bucket 7: 60%
  bucket 3: 90%
  bucket 7: 70%
  bucket 8: 100%
  Sorting block of length 190 for bucket 6
  (Using difference cover)
  Sorting block of length 67 for bucket 5
  (Using difference cover)
  bucket 7: 80%
  Sorting block of length 115 for bucket 8
  (Using difference cover)
  bucket 3: 100%
  bucket 4: 70%
  bucket 7: 90%
  Sorting block of length 152 for bucket 3
  (Using difference cover)
  bucket 7: 100%
  bucket 4: 80%
  Sorting block of length 182 for bucket 7
  (Using difference cover)
  bucket 4: 90%
  bucket 4: 100%
  Sorting block of length 156 for bucket 4
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 144 for bucket 1
  Sorting block time: 00:00:00
Returning block of 153 for bucket 3
  Sorting block time: 00:00:00
Returning block of 68 for bucket 5
  Sorting block time: 00:00:00
Returning block of 78 for bucket 2
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 157 for bucket 4
  Sorting block time: 00:00:00
Returning block of 191 for bucket 6
Returning block of 183 for bucket 7
  Sorting block time: 00:00:00
Returning block of 116 for bucket 8
Exited GFM loop
fchr[A]: 0
fchr[C]: 150
fchr[G]: 600
fchr[T]: 959
fchr[$]: 1089
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4194906 bytes to primary GFM file: ZMP-ZTP_index/ZMP-ZTP_index.1.ht2
Wrote 280 bytes to secondary GFM file: ZMP-ZTP_index/ZMP-ZTP_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 8613 bytes to primary GFM file: ZMP-ZTP_index/ZMP-ZTP_index.5.ht2
Wrote 278 bytes to secondary GFM file: ZMP-ZTP_index/ZMP-ZTP_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 1089
    gbwtLen: 1090
    nodes: 1090
    sz: 273
    gbwtSz: 273
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 69
    offsSz: 276
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 6
    numLines: 6
    gbwtTotLen: 384
    gbwtTotSz: 384
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "Cobalamin_index/Cobalamin_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  Cobalamin.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 214 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 214 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 11 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 189.167 (target: 213)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 6
  Reserving size (214) for bucket 1
Getting block 2 of 6
Getting block 3 of 6
  Reserving size (214) for bucket 2
  Reserving size (214) for bucket 3
  Calculating Z arrays for bucket 1
  Calculating Z arrays for bucket 3
Getting block 5 of 6
Getting block 4 of 6
  Calculating Z arrays for bucket 2
Getting block 6 of 6
  Entering block accumulator loop for bucket 1:
  Entering block accumulator loop for bucket 2:
  Reserving size (214) for bucket 4
  Entering block accumulator loop for bucket 3:
  Reserving size (214) for bucket 6
  bucket 3: 10%
  Reserving size (214) for bucket 5
  Calculating Z arrays for bucket 6
  Calculating Z arrays for bucket 4
  Calculating Z arrays for bucket 5
  bucket 1: 10%
  Entering block accumulator loop for bucket 6:
  bucket 3: 20%
  Entering block accumulator loop for bucket 5:
  bucket 3: 30%
  bucket 6: 10%
  bucket 1: 20%
  bucket 3: 40%
  bucket 1: 30%
  bucket 2: 10%
  bucket 1: 40%
  Entering block accumulator loop for bucket 4:
  bucket 1: 50%
  bucket 2: 20%
  bucket 1: 60%
  bucket 2: 30%
  bucket 5: 10%
  bucket 2: 40%
  bucket 6: 20%
  bucket 1: 70%
  bucket 2: 50%
  bucket 5: 20%
  bucket 2: 60%
  bucket 3: 50%
  bucket 2: 70%
  bucket 4: 10%
  bucket 3: 60%
  bucket 2: 80%
  bucket 4: 20%
  bucket 6: 30%
  bucket 2: 90%
  bucket 3: 70%
  bucket 2: 100%
  bucket 1: 80%
  bucket 5: 30%
  bucket 4: 30%
  bucket 6: 40%
  bucket 4: 40%
  bucket 5: 40%
  bucket 3: 80%
  bucket 1: 90%
  bucket 4: 50%
  Sorting block of length 203 for bucket 2
  bucket 3: 90%
  (Using difference cover)
  bucket 1: 100%
  Sorting block of length 206 for bucket 1
  (Using difference cover)
  bucket 5: 50%
  bucket 3: 100%
  Sorting block of length 158 for bucket 3
  (Using difference cover)
  bucket 4: 60%
  bucket 6: 50%
  bucket 5: 60%
  bucket 4: 70%
  bucket 5: 70%
  bucket 6: 60%
  bucket 5: 80%
  bucket 4: 80%
  bucket 5: 90%
  bucket 4: 90%
  bucket 6: 70%
  bucket 5: 100%
  bucket 6: 80%
  bucket 4: 100%
  Sorting block of length 181 for bucket 4
  (Using difference cover)
  bucket 6: 90%
  Sorting block of length 212 for bucket 5
  (Using difference cover)
  bucket 6: 100%
  Sorting block of length 175 for bucket 6
  (Using difference cover)
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 159 for bucket 3
  Sorting block time: 00:00:00
Returning block of 204 for bucket 2
Returning block of 182 for bucket 4
Returning block of 207 for bucket 1
  Sorting block time: 00:00:00
Returning block of 176 for bucket 6
  Sorting block time: 00:00:00
Returning block of 213 for bucket 5
Exited GFM loop
fchr[A]: 0
fchr[C]: 225
fchr[G]: 550
fchr[T]: 847
fchr[$]: 1140
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4194908 bytes to primary GFM file: Cobalamin_index/Cobalamin_index.1.ht2
Wrote 292 bytes to secondary GFM file: Cobalamin_index/Cobalamin_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 8677 bytes to primary GFM file: Cobalamin_index/Cobalamin_index.5.ht2
Wrote 290 bytes to secondary GFM file: Cobalamin_index/Cobalamin_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 1140
    gbwtLen: 1141
    nodes: 1141
    sz: 285
    gbwtSz: 286
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 72
    offsSz: 288
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 6
    numLines: 6
    gbwtTotLen: 384
    gbwtTotSz: 384
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "glnA_index/glnA_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  glnA.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 199 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 199 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 2, merged 7; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 1; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 131.75 (target: 198)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 8
  Reserving size (199) for bucket 1
Getting block 3 of 8
  Reserving size (199) for bucket 3
Getting block 2 of 8
  Reserving size (199) for bucket 2
Getting block 4 of 8
  Reserving size (199) for bucket 4
  Calculating Z arrays for bucket 1
  Calculating Z arrays for bucket 2
  Calculating Z arrays for bucket 4
Getting block 5 of 8
  Entering block accumulator loop for bucket 4:
Getting block 7 of 8
  Entering block accumulator loop for bucket 2:
  Reserving size (199) for bucket 5
Getting block 6 of 8
Getting block 8 of 8
  Reserving size (199) for bucket 8
  bucket 4: 10%
  Calculating Z arrays for bucket 5
  bucket 2: 10%
  Reserving size (199) for bucket 7
  Calculating Z arrays for bucket 3
  Calculating Z arrays for bucket 8
  Calculating Z arrays for bucket 7
  bucket 4: 20%
  Reserving size (199) for bucket 6
  bucket 4: 30%
  bucket 2: 20%
  bucket 4: 40%
  Entering block accumulator loop for bucket 1:
  Entering block accumulator loop for bucket 5:
  bucket 2: 30%
  Entering block accumulator loop for bucket 3:
  bucket 5: 10%
  Entering block accumulator loop for bucket 8:
  bucket 2: 40%
  Entering block accumulator loop for bucket 7:
  bucket 5: 20%
  Calculating Z arrays for bucket 6
  bucket 1: 10%
  bucket 2: 50%
  bucket 4: 50%
  bucket 5: 30%
  bucket 2: 60%
  bucket 5: 40%
  bucket 7: 10%
  bucket 2: 70%
  bucket 5: 50%
  bucket 1: 20%
  bucket 8: 10%
  bucket 2: 80%
  bucket 3: 10%
  bucket 2: 90%
  bucket 7: 20%
  bucket 4: 60%
  bucket 2: 100%
  bucket 7: 30%
  bucket 5: 60%
  Sorting block of length 128 for bucket 2
  (Using difference cover)
  Entering block accumulator loop for bucket 6:
  bucket 3: 20%
  bucket 4: 70%
  bucket 7: 40%
  bucket 5: 70%
  bucket 1: 30%
  bucket 6: 10%
  bucket 5: 80%
  bucket 4: 80%
  bucket 1: 40%
  bucket 3: 30%
  bucket 4: 90%
  bucket 8: 20%
  bucket 6: 20%
  bucket 5: 90%
  bucket 7: 50%
  bucket 6: 30%
  bucket 7: 60%
  bucket 8: 30%
  bucket 6: 40%
  bucket 8: 40%
  bucket 5: 100%
  bucket 6: 50%
  bucket 7: 70%
  Sorting block of length 114 for bucket 5
  bucket 7: 80%
  (Using difference cover)
  bucket 3: 40%
  bucket 6: 60%
  bucket 7: 90%
  bucket 3: 50%
  bucket 7: 100%
  Sorting block of length 145 for bucket 7
  bucket 4: 100%
  (Using difference cover)
  bucket 6: 70%
  bucket 8: 50%
  bucket 6: 80%
  bucket 1: 50%
  Sorting block of length 96 for bucket 4
  (Using difference cover)
  bucket 6: 90%
  bucket 8: 60%
  bucket 3: 60%
  bucket 8: 70%
  bucket 3: 70%
  bucket 8: 80%
  bucket 6: 100%
  bucket 3: 80%
  Sorting block of length 174 for bucket 6
  bucket 8: 90%
  bucket 3: 90%
  bucket 1: 60%
  bucket 3: 100%
  bucket 8: 100%
  (Using difference cover)
  Sorting block of length 147 for bucket 3
  (Using difference cover)
  Sorting block of length 79 for bucket 8
  (Using difference cover)
  bucket 1: 70%
  bucket 1: 80%
  bucket 1: 90%
  bucket 1: 100%
  Sorting block of length 171 for bucket 1
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 129 for bucket 2
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 80 for bucket 8
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 97 for bucket 4
Returning block of 175 for bucket 6
  Sorting block time: 00:00:00
Returning block of 148 for bucket 3
  Sorting block time: 00:00:00
Returning block of 172 for bucket 1
Returning block of 146 for bucket 7
  Sorting block time: 00:00:00
Returning block of 115 for bucket 5
Exited GFM loop
fchr[A]: 0
fchr[C]: 305
fchr[G]: 562
fchr[T]: 798
fchr[$]: 1061
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4194901 bytes to primary GFM file: glnA_index/glnA_index.1.ht2
Wrote 272 bytes to secondary GFM file: glnA_index/glnA_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 8613 bytes to primary GFM file: glnA_index/glnA_index.5.ht2
Wrote 270 bytes to secondary GFM file: glnA_index/glnA_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 1061
    gbwtLen: 1062
    nodes: 1062
    sz: 266
    gbwtSz: 266
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 67
    offsSz: 268
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 6
    numLines: 6
    gbwtTotLen: 384
    gbwtTotSz: 384
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:01
Settings:
  Output files: "TPP_index/TPP_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  TPP.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 205 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 205 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 155.571 (target: 204)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 7
  Reserving size (205) for bucket 1
Getting block 2 of 7
  Reserving size (205) for bucket 2
  Calculating Z arrays for bucket 1
  Calculating Z arrays for bucket 2
Getting block 4 of 7
  Reserving size (205) for bucket 4
Getting block 5 of 7
  Entering block accumulator loop for bucket 1:
Getting block 3 of 7
  Reserving size (205) for bucket 3
  Calculating Z arrays for bucket 4
  Reserving size (205) for bucket 5
Getting block 7 of 7
  Reserving size (205) for bucket 7
  Calculating Z arrays for bucket 3
  Calculating Z arrays for bucket 5
Getting block 6 of 7
  Calculating Z arrays for bucket 7
  Entering block accumulator loop for bucket 2:
  Entering block accumulator loop for bucket 5:
  bucket 1: 10%
  Reserving size (205) for bucket 6
  Entering block accumulator loop for bucket 4:
  bucket 1: 20%
  bucket 4: 10%
  Entering block accumulator loop for bucket 3:
  bucket 4: 20%
  bucket 2: 10%
  bucket 3: 10%
  bucket 4: 30%
  Calculating Z arrays for bucket 6
  bucket 4: 40%
  Entering block accumulator loop for bucket 7:
  Entering block accumulator loop for bucket 6:
  bucket 3: 20%
  bucket 7: 10%
  bucket 6: 10%
  bucket 5: 10%
  bucket 3: 30%
  bucket 2: 20%
  bucket 5: 20%
  bucket 2: 30%
  bucket 7: 20%
  bucket 5: 30%
  bucket 7: 30%
  bucket 2: 40%
  bucket 5: 40%
  bucket 3: 40%
  bucket 4: 50%
  bucket 5: 50%
  bucket 7: 40%
  bucket 1: 30%
  bucket 7: 50%
  bucket 1: 40%
  bucket 5: 60%
  bucket 3: 50%
  bucket 2: 50%
  bucket 7: 60%
  bucket 4: 60%
  bucket 3: 60%
  bucket 7: 70%
  bucket 4: 70%
  bucket 3: 70%
  bucket 6: 20%
  bucket 2: 60%
  bucket 6: 30%
  bucket 4: 80%
  bucket 5: 70%
  bucket 3: 80%
  bucket 4: 90%
  bucket 1: 50%
  bucket 5: 80%
  bucket 1: 60%
  bucket 6: 40%
  bucket 4: 100%
  bucket 1: 70%
  bucket 3: 90%
  bucket 7: 80%
  bucket 5: 90%
  Sorting block of length 192 for bucket 4
  bucket 7: 90%
  bucket 1: 80%
  (Using difference cover)
  bucket 3: 100%
  bucket 7: 100%
  Sorting block of length 186 for bucket 3
  (Using difference cover)
  bucket 5: 100%
  bucket 6: 50%
  Sorting block of length 45 for bucket 7
  bucket 6: 60%
  bucket 2: 70%
  (Using difference cover)
  Sorting block of length 166 for bucket 5
  (Using difference cover)
  bucket 2: 80%
  bucket 6: 70%
  bucket 2: 90%
  bucket 6: 80%
  bucket 1: 90%
  bucket 6: 90%
  bucket 2: 100%
  bucket 1: 100%
  bucket 6: 100%
  Sorting block of length 200 for bucket 2
  (Using difference cover)
  Sorting block of length 128 for bucket 1
  (Using difference cover)
  Sorting block of length 172 for bucket 6
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 129 for bucket 1
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 173 for bucket 6
Returning block of 187 for bucket 3
Returning block of 167 for bucket 5
Returning block of 46 for bucket 7
Returning block of 193 for bucket 4
  Sorting block time: 00:00:00
Returning block of 201 for bucket 2
Exited GFM loop
fchr[A]: 0
fchr[C]: 291
fchr[G]: 535
fchr[T]: 761
fchr[$]: 1095
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4194902 bytes to primary GFM file: TPP_index/TPP_index.1.ht2
Wrote 280 bytes to secondary GFM file: TPP_index/TPP_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 8613 bytes to primary GFM file: TPP_index/TPP_index.5.ht2
Wrote 278 bytes to secondary GFM file: TPP_index/TPP_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 1095
    gbwtLen: 1096
    nodes: 1096
    sz: 274
    gbwtSz: 275
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 69
    offsSz: 276
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 6
    numLines: 6
    gbwtTotLen: 384
    gbwtTotSz: 384
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "ydaO-yuaA_index/ydaO-yuaA_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  ydaO-yuaA.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 216 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 216 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 6; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 1; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 190.667 (target: 215)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 6
Getting block 3 of 6
  Reserving size (216) for bucket 3
Getting block 2 of 6
  Reserving size (216) for bucket 2
Getting block 4 of 6
  Reserving size (216) for bucket 4
  Reserving size (216) for bucket 1
  Calculating Z arrays for bucket 4
Getting block 5 of 6
  Entering block accumulator loop for bucket 4:
  Calculating Z arrays for bucket 3
Getting block 6 of 6
  Reserving size (216) for bucket 5
  Reserving size (216) for bucket 6
  Calculating Z arrays for bucket 5
  bucket 4: 10%
  Calculating Z arrays for bucket 1
  Calculating Z arrays for bucket 2
  Entering block accumulator loop for bucket 1:
  Calculating Z arrays for bucket 6
  Entering block accumulator loop for bucket 5:
  bucket 1: 10%
  Entering block accumulator loop for bucket 2:
  Entering block accumulator loop for bucket 6:
  Entering block accumulator loop for bucket 3:
  bucket 2: 10%
  bucket 6: 10%
  bucket 5: 10%
  bucket 1: 20%
  bucket 6: 20%
  bucket 1: 30%
  bucket 2: 20%
  bucket 4: 20%
  bucket 2: 30%
  bucket 5: 20%
  bucket 1: 40%
  bucket 6: 30%
  bucket 3: 10%
  bucket 5: 30%
  bucket 2: 40%
  bucket 3: 20%
  bucket 4: 30%
  bucket 6: 40%
  bucket 1: 50%
  bucket 6: 50%
  bucket 4: 40%
  bucket 6: 60%
  bucket 1: 60%
  bucket 6: 70%
  bucket 1: 70%
  bucket 5: 40%
  bucket 1: 80%
  bucket 6: 80%
  bucket 4: 50%
  bucket 2: 50%
  bucket 6: 90%
  bucket 5: 50%
  bucket 3: 30%
  bucket 4: 60%
  bucket 2: 60%
  bucket 5: 60%
  bucket 4: 70%
  bucket 6: 100%
  bucket 5: 70%
  bucket 2: 70%
  bucket 4: 80%
  bucket 2: 80%
  bucket 3: 40%
  Sorting block of length 151 for bucket 6
  (Using difference cover)
  bucket 4: 90%
  bucket 1: 90%
  bucket 2: 90%
  bucket 1: 100%
  bucket 3: 50%
  bucket 5: 80%
  bucket 3: 60%
  Sorting block of length 214 for bucket 1
  (Using difference cover)
  bucket 2: 100%
  bucket 4: 100%
  bucket 5: 90%
  bucket 3: 70%
  Sorting block of length 194 for bucket 4
  (Using difference cover)
  bucket 5: 100%
  bucket 3: 80%
  Sorting block of length 192 for bucket 5
  (Using difference cover)
  bucket 3: 90%
  Sorting block of length 211 for bucket 2
  (Using difference cover)
  bucket 3: 100%
  Sorting block of length 182 for bucket 3
  (Using difference cover)
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 212 for bucket 2
  Sorting block time: 00:00:00
Returning block of 152 for bucket 6
Returning block of 215 for bucket 1
  Sorting block time: 00:00:00
Returning block of 183 for bucket 3
  Sorting block time: 00:00:00
Returning block of 195 for bucket 4
  Sorting block time: 00:00:00
Returning block of 193 for bucket 5
Exited GFM loop
fchr[A]: 0
fchr[C]: 337
fchr[G]: 560
fchr[T]: 812
fchr[$]: 1149
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4194908 bytes to primary GFM file: ydaO-yuaA_index/ydaO-yuaA_index.1.ht2
Wrote 292 bytes to secondary GFM file: ydaO-yuaA_index/ydaO-yuaA_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 8677 bytes to primary GFM file: ydaO-yuaA_index/ydaO-yuaA_index.5.ht2
Wrote 292 bytes to secondary GFM file: ydaO-yuaA_index/ydaO-yuaA_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 1149
    gbwtLen: 1150
    nodes: 1150
    sz: 288
    gbwtSz: 288
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 72
    offsSz: 288
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 6
    numLines: 6
    gbwtTotLen: 384
    gbwtTotSz: 384
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
Settings:
  Output files: "ykkC-yxkD_index/ykkC-yxkD_index.*.ht2"
  Line rate: 6 (line is 64 bytes)
  Lines per side: 1 (side is 64 bytes)
  Offset rate: 4 (one in 16)
  FTable chars: 10
  Strings: unpacked
  Local offset rate: 3 (one in 8)
  Local fTable chars: 6
  Local sequence length: 57344
  Local sequence overlap between two consecutive indexes: 1024
  Endianness: little
  Actual local endianness: little
  Sanity checking: disabled
  Assertions: disabled
  Random seed: 0
  Sizeofs: void*:8, int:4, long:8, size_t:8
Input files DNA, FASTA:
  ykkC-yxkD.fna
Reading reference sizes
  Time reading reference sizes: 00:00:00
Calculating joined length
Writing header
Reserving space for joined string
Joining reference sequences
  Time to join reference sequences: 00:00:00
  Time to read SNPs and splice sites: 00:00:00
Using parameters --bmax 210 --dcv 1024
  Doing ahead-of-time memory usage test
  Passed!  Constructing with these parameters: --bmax 210 --dcv 1024
Constructing suffix-array element generator
Building DifferenceCoverSample
  Building sPrime
  Building sPrimeOrder
  V-Sorting samples
  V-Sorting samples time: 00:00:00
  Allocating rank array
  Ranking v-sort output
  Ranking v-sort output time: 00:00:00
  Invoking Larsson-Sadakane on ranks
  Invoking Larsson-Sadakane on ranks time: 00:00:00
  Sanity-checking and returning
Building samples
Reserving space for 12 sample suffixes
Generating random suffixes
QSorting 12 sample offsets, eliminating duplicates
QSorting sample offsets, eliminating duplicates time: 00:00:00
Multikey QSorting 12 samples
  (Using difference cover)
  Multikey QSorting samples time: 00:00:00
Calculating bucket sizes
Splitting and merging
  Splitting and merging time: 00:00:00
Split 1, merged 6; iterating...
Splitting and merging
  Splitting and merging time: 00:00:00
Avg bucket size: 139.25 (target: 209)
Converting suffix-array elements to index image
Allocating ftab, absorbFtab
Entering GFM loop
Getting block 1 of 8
  Reserving size (210) for bucket 1
Getting block 2 of 8
  Reserving size (210) for bucket 2
  Calculating Z arrays for bucket 1
Getting block 4 of 8
  Calculating Z arrays for bucket 2
Getting block 3 of 8
  Entering block accumulator loop for bucket 2:
  Reserving size (210) for bucket 3
Getting block 6 of 8
  Calculating Z arrays for bucket 3
Getting block 5 of 8
  Reserving size (210) for bucket 4
  Reserving size (210) for bucket 5
  Entering block accumulator loop for bucket 3:
Getting block 8 of 8
  Calculating Z arrays for bucket 5
  Reserving size (210) for bucket 8
Getting block 7 of 8
  bucket 2: 10%
  Reserving size (210) for bucket 7
  Calculating Z arrays for bucket 4
  Entering block accumulator loop for bucket 5:
  bucket 3: 10%
  Reserving size (210) for bucket 6
  bucket 2: 20%
  Calculating Z arrays for bucket 7
  Entering block accumulator loop for bucket 1:
  bucket 3: 20%
  bucket 1: 10%
  Calculating Z arrays for bucket 8
  Entering block accumulator loop for bucket 4:
  Calculating Z arrays for bucket 6
  bucket 1: 20%
  bucket 2: 30%
  bucket 3: 30%
  bucket 5: 10%
  Entering block accumulator loop for bucket 7:
  Entering block accumulator loop for bucket 6:
  bucket 1: 30%
  bucket 5: 20%
  bucket 3: 40%
  bucket 7: 10%
  bucket 5: 30%
  bucket 1: 40%
  bucket 5: 40%
  bucket 7: 20%
  bucket 4: 10%
  bucket 6: 10%
  bucket 5: 50%
  Entering block accumulator loop for bucket 8:
  bucket 6: 20%
  bucket 4: 20%
  bucket 1: 50%
  bucket 7: 30%
  bucket 4: 30%
  bucket 3: 50%
  bucket 8: 10%
  bucket 5: 60%
  bucket 1: 60%
  bucket 3: 60%
  bucket 7: 40%
  bucket 5: 70%
  bucket 4: 40%
  bucket 7: 50%
  bucket 8: 20%
  bucket 2: 40%
  bucket 7: 60%
  bucket 3: 70%
  bucket 5: 80%
  bucket 2: 50%
  bucket 8: 30%
  bucket 4: 50%
  bucket 2: 60%
  bucket 5: 90%
  bucket 7: 70%
  bucket 6: 30%
  bucket 2: 70%
  bucket 1: 70%
  bucket 8: 40%
  bucket 1: 80%
  bucket 5: 100%
  bucket 6: 40%
  bucket 1: 90%
  bucket 7: 80%
  Sorting block of length 172 for bucket 5
  bucket 7: 90%
  bucket 3: 80%
  (Using difference cover)
  bucket 1: 100%
  bucket 3: 90%
  bucket 7: 100%
  bucket 8: 50%
  bucket 2: 80%
  bucket 3: 100%
  bucket 8: 60%
  Sorting block of length 171 for bucket 3
  (Using difference cover)
  Sorting block of length 52 for bucket 1
  (Using difference cover)
  bucket 4: 60%
  Sorting block of length 202 for bucket 7
  (Using difference cover)
  bucket 4: 70%
  bucket 6: 50%
  bucket 2: 90%
  bucket 8: 70%
  bucket 6: 60%
  bucket 8: 80%
  bucket 6: 70%
  bucket 2: 100%
  Sorting block of length 209 for bucket 2
  (Using difference cover)
  bucket 4: 80%
  bucket 6: 80%
  bucket 4: 90%
  bucket 8: 90%
  bucket 4: 100%
  Sorting block of length 124 for bucket 4
  (Using difference cover)
  bucket 8: 100%
  Sorting block of length 104 for bucket 8
  (Using difference cover)
  bucket 6: 90%
  bucket 6: 100%
  Sorting block of length 80 for bucket 6
  (Using difference cover)
  Sorting block time: 00:00:00
Returning block of 173 for bucket 5
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 53 for bucket 1
Returning block of 172 for bucket 3
  Sorting block time: 00:00:00
Returning block of 105 for bucket 8
  Sorting block time: 00:00:00
Returning block of 203 for bucket 7
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
  Sorting block time: 00:00:00
Returning block of 125 for bucket 4
Returning block of 210 for bucket 2
Returning block of 81 for bucket 6
Exited GFM loop
fchr[A]: 0
fchr[C]: 281
fchr[G]: 531
fchr[T]: 822
fchr[$]: 1121
Exiting GFM::buildToDisk()
Returning from initFromVector
Wrote 4194906 bytes to primary GFM file: ykkC-yxkD_index/ykkC-yxkD_index.1.ht2
Wrote 288 bytes to secondary GFM file: ykkC-yxkD_index/ykkC-yxkD_index.2.ht2
Re-opening _in1 and _in2 as input streams
Returning from GFM constructor
Returning from initFromVector
Wrote 8677 bytes to primary GFM file: ykkC-yxkD_index/ykkC-yxkD_index.5.ht2
Wrote 286 bytes to secondary GFM file: ykkC-yxkD_index/ykkC-yxkD_index.6.ht2
Re-opening _in5 and _in5 as input streams
Returning from HierEbwt constructor
Headers:
    len: 1121
    gbwtLen: 1122
    nodes: 1122
    sz: 281
    gbwtSz: 281
    lineRate: 6
    offRate: 4
    offMask: 0xfffffff0
    ftabChars: 10
    eftabLen: 0
    eftabSz: 0
    ftabLen: 1048577
    ftabSz: 4194308
    offsLen: 71
    offsSz: 284
    lineSz: 64
    sideSz: 64
    sideGbwtSz: 48
    sideGbwtLen: 192
    numSides: 6
    numLines: 6
    gbwtTotLen: 384
    gbwtTotSz: 384
    reverse: 0
    linearFM: Yes
Total time for call to driver() for forward index: 00:00:00
